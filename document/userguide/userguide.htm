<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0063)http://baike.corp.taobao.com/index.php/Metaq-User-Guide -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-hans" lang="zh-hans" dir="ltr"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

		<meta http-equiv="Content-Style-Type" content="text/css">
		<meta name="generator" content="MediaWiki 1.14.0">
		<meta name="keywords" content="Metaq-User-Guide,">
		<link rel="shortcut icon" href="http://baike.corp.taobao.com/favicon.ico">
		<link rel="search" type="application/opensearchdescription+xml" href="http://baike.corp.taobao.com/opensearch_desc.php" title="淘宝百科 (zh-hans)">
		<link rel="alternate" type="application/rss+xml" title="淘宝百科的RSS订阅" href="http://baike.corp.taobao.com/index.php?title=Special:%E6%9C%80%E8%BF%91%E6%9B%B4%E6%94%B9&feed=rss">
		<link rel="alternate" type="application/atom+xml" title="淘宝百科的Atom订阅" href="http://baike.corp.taobao.com/index.php?title=Special:%E6%9C%80%E8%BF%91%E6%9B%B4%E6%94%B9&feed=atom">
		<title>Metaq-User-Guide - 淘宝百科</title>
		<link rel="stylesheet" href="./userguide_files/shared.css" type="text/css" media="screen">
		<link rel="stylesheet" href="./userguide_files/main.css" type="text/css" media="screen">
		<link rel="stylesheet" href="./userguide_files/print.css" type="text/css" media="print">
		<link rel="stylesheet" href="./userguide_files/index.php" type="text/css">
		<link rel="stylesheet" href="./userguide_files/index(1).php" type="text/css" media="print">
		<link rel="stylesheet" href="./userguide_files/index(2).php" type="text/css">
		<link rel="stylesheet" href="./userguide_files/index(3).php" type="text/css">		<!--[if lt IE 7]><meta http-equiv="imagetoolbar" content="no" /><![endif]-->

		<script type="text/javascript">/*<![CDATA[*/
		var skin = "modern";
		var stylepath = "/skins";
		var wgArticlePath = "/index.php/$1";
		var wgScriptPath = "";
		var wgScript = "/index.php";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = "http://baike.corp.taobao.com";
		var wgCanonicalNamespace = "";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = "Metaq-User-Guide";
		var wgTitle = "Metaq-User-Guide";
		var wgAction = "view";
		var wgArticleId = "8939";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = "zh-hans";
		var wgContentLanguage = "zh-hans";
		var wgBreakFrames = false;
		var wgCurRevisionId = "239352";
		var wgVersion = "1.14.0";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = ["", ""];
		var wgDigitTransformTable = ["", ""];
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		/*]]>*/</script>

		<script type="text/javascript" src="./userguide_files/wikibits.js"><!-- wikibits js --></script><style type="text/css">@import "/skins/modern/KHTMLFixes.css";</style>
		<!-- Head Scripts -->
		<script type="text/javascript" src="./userguide_files/ajax.js"></script>
<style type="text/css">/*<![CDATA[*/
.source-java {line-height: normal;}
.source-java li, .source-java pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for java
 * CSS class: source-java, CSS id:
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.java.source-java .de1, .java.source-java .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.java.source-java  {font-family:monospace;}
.java.source-java .imp {font-weight: bold; color: red;}
.java.source-java li, .java.source-java .li1 {font-weight: normal; vertical-align:top;}
.java.source-java .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.java.source-java .li2 {font-weight: bold; vertical-align:top;}
.java.source-java .kw1 {color: #000000; font-weight: bold;}
.java.source-java .kw2 {color: #000066; font-weight: bold;}
.java.source-java .kw3 {color: #003399;}
.java.source-java .kw4 {color: #000066; font-weight: bold;}
.java.source-java .co1 {color: #666666; font-style: italic;}
.java.source-java .co2 {color: #006699;}
.java.source-java .co3 {color: #008000; font-style: italic; font-weight: bold;}
.java.source-java .coMULTI {color: #666666; font-style: italic;}
.java.source-java .es0 {color: #000099; font-weight: bold;}
.java.source-java .br0 {color: #009900;}
.java.source-java .sy0 {color: #339933;}
.java.source-java .st0 {color: #0000ff;}
.java.source-java .nu0 {color: #cc66cc;}
.java.source-java .me1 {color: #006633;}
.java.source-java .me2 {color: #006633;}
.java.source-java .ln-xtra, .java.source-java li.ln-xtra, .java.source-java div.ln-xtra {background-color: #ffc;}
.java.source-java span.xtra { display:block; }

/*]]>*/
</style>
<style type="text/css">/*<![CDATA[*/
@import "/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=18000";
/*]]>*/
</style>		<script type="text/javascript" src="./userguide_files/index(4).php"><!-- site js --></script>
	</head>
<body class="mediawiki ltr ns-0 ns-subject page-Metaq-User-Guide skin-modern">
	<div id="mw_main">
	<div id="mw_contentwrapper">
	<!-- navigation portlet --><!-- content -->
	<div id="mw_content">
	<!-- contentholder does nothing by default, but it allows users to style the text inside
	     the content area without affecting the meaning of 'em' in #mw_content, which is used
	     for the margins -->
	<div id="mw_contentholder">
		<div class="mw-topboxes">
			<div id="mw-js-message" style="display:none;"></div>
			<div class="mw-topbox" id="siteSub">出自淘宝百科</div>
								</div>

		<div id="contentSub"></div>

				<div id="jump-to-nav">跳转到: <a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#mw_portlets">导航</a>, <a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#searchInput">搜索</a></div>
		<p><b>Metaq用户指南</b>
</p>
<table cellspacing="0" id="toc" class="toc" summary="目录"><tbody><tr><td><div id="toctitle"><h2>目录</h2> <span class="toctoggle">[<a id="togglelink" class="internal" href="javascript:toggleToc()">隐藏</a>]</span></div>
<ul>
<li class="toclevel-1"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E7.89.88.E6.9C.AC"><span class="tocnumber">1</span> <span class="toctext">版本</span></a></li>
<li class="toclevel-1"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E7.AE.80.E4.BB.8B"><span class="tocnumber">2</span> <span class="toctext">简介</span></a></li>
<li class="toclevel-1"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#Metaq.E7.9A.84.E7.89.B9.E7.82.B9"><span class="tocnumber">3</span> <span class="toctext">Metaq的特点</span></a></li>
<li class="toclevel-1"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#Getting_started"><span class="tocnumber">4</span> <span class="toctext">Getting started</span></a>
<ul>
<li class="toclevel-2"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E6.B6.88.E6.81.AF.E4.BC.9A.E8.AF.9D.E5.B7.A5.E5.8E.82.E7.B1.BB"><span class="tocnumber">4.1</span> <span class="toctext">消息会话工厂类</span></a></li>
<li class="toclevel-2"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E6.B6.88.E6.81.AF.E7.94.9F.E4.BA.A7.E8.80.85"><span class="tocnumber">4.2</span> <span class="toctext">消息生产者</span></a></li>
<li class="toclevel-2"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E6.B6.88.E6.81.AF.E6.B6.88.E8.B4.B9.E8.80.85"><span class="tocnumber">4.3</span> <span class="toctext">消息消费者</span></a></li>
<li class="toclevel-2"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E4.BE.8B.E5.AD.90.E5.B0.8F.E7.BB.93"><span class="tocnumber">4.4</span> <span class="toctext">例子小结</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E4.BA.8B.E5.8A.A1"><span class="tocnumber">5</span> <span class="toctext">事务</span></a>
<ul>
<li class="toclevel-2"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E5.8F.91.E9.80.81.E6.B6.88.E6.81.AF.E7.9A.84.E6.9C.AC.E5.9C.B0.E4.BA.8B.E5.8A.A1"><span class="tocnumber">5.1</span> <span class="toctext">发送消息的本地事务</span></a></li>
<li class="toclevel-2"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E5.8F.91.E9.80.81.E6.B6.88.E6.81.AF.E7.9A.84.E5.88.86.E5.B8.83.E5.BC.8F.E4.BA.8B.E5.8A.A1"><span class="tocnumber">5.2</span> <span class="toctext">发送消息的分布式事务</span></a></li>
<li class="toclevel-2"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E6.B6.88.E8.B4.B9.E8.80.85.E7.9A.84.E4.BA.8B.E5.8A.A1"><span class="tocnumber">5.3</span> <span class="toctext">消费者的事务</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E6.A6.82.E5.BF.B5.E5.92.8CAPI.E8.AF.A6.E8.A7.A3"><span class="tocnumber">6</span> <span class="toctext">概念和API详解</span></a>
<ul>
<li class="toclevel-2"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E6.9C.AF.E8.AF.AD.E8.A7.A3.E9.87.8A"><span class="tocnumber">6.1</span> <span class="toctext">术语解释</span></a>
<ul>
<li class="toclevel-3"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E6.B6.88.E6.81.AF.E7.94.9F.E4.BA.A7.E8.80.85_2"><span class="tocnumber">6.1.1</span> <span class="toctext">消息生产者</span></a></li>
<li class="toclevel-3"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E6.B6.88.E6.81.AF.E6.B6.88.E8.B4.B9.E8.80.85_2"><span class="tocnumber">6.1.2</span> <span class="toctext">消息消费者</span></a></li>
<li class="toclevel-3"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#Topic"><span class="tocnumber">6.1.3</span> <span class="toctext">Topic</span></a></li>
<li class="toclevel-3"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E5.88.86.E5.8C.BA.28partition.29"><span class="tocnumber">6.1.4</span> <span class="toctext">分区(partition)</span></a></li>
<li class="toclevel-3"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#Message"><span class="tocnumber">6.1.5</span> <span class="toctext">Message</span></a></li>
<li class="toclevel-3"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#Broker"><span class="tocnumber">6.1.6</span> <span class="toctext">Broker</span></a></li>
<li class="toclevel-3"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E6.B6.88.E8.B4.B9.E8.80.85.E5.88.86.E7.BB.84.28Group.29"><span class="tocnumber">6.1.7</span> <span class="toctext">消费者分组(Group)</span></a></li>
<li class="toclevel-3"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#Offset"><span class="tocnumber">6.1.8</span> <span class="toctext">Offset</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E5.AE.A2.E6.88.B7.E7.AB.AFAPI"><span class="tocnumber">6.2</span> <span class="toctext">客户端API</span></a>
<ul>
<li class="toclevel-3"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#MessageSessionFactory.E6.8E.A5.E5.8F.A3"><span class="tocnumber">6.2.1</span> <span class="toctext">MessageSessionFactory接口</span></a></li>
<li class="toclevel-3"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#MessageProducer.E6.8E.A5.E5.8F.A3"><span class="tocnumber">6.2.2</span> <span class="toctext">MessageProducer接口</span></a>
<ul>
<li class="toclevel-4"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#PartitionSelector.E6.8E.A5.E5.8F.A3"><span class="tocnumber">6.2.2.1</span> <span class="toctext">PartitionSelector接口</span></a></li>
<li class="toclevel-4"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#SendResult.E7.B1.BB"><span class="tocnumber">6.2.2.2</span> <span class="toctext">SendResult类</span></a></li>
</ul>
</li>
<li class="toclevel-3"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#MessageConsumer.E6.8E.A5.E5.8F.A3"><span class="tocnumber">6.2.3</span> <span class="toctext">MessageConsumer接口</span></a>
<ul>
<li class="toclevel-4"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#MessageListener.E6.8E.A5.E5.8F.A3"><span class="tocnumber">6.2.3.1</span> <span class="toctext">MessageListener接口</span></a></li>
<li class="toclevel-4"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#OffsetStorage.E6.8E.A5.E5.8F.A3"><span class="tocnumber">6.2.3.2</span> <span class="toctext">OffsetStorage接口</span></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E5.8F.AF.E9.9D.A0.E6.80.A7.E3.80.81.E9.A1.BA.E5.BA.8F.E5.92.8C.E9.87.8D.E5.A4.8D"><span class="tocnumber">7</span> <span class="toctext">可靠性、顺序和重复</span></a>
<ul>
<li class="toclevel-2"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E5.8F.AF.E9.9D.A0.E6.80.A7"><span class="tocnumber">7.1</span> <span class="toctext">可靠性</span></a>
<ul>
<li class="toclevel-3"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E7.94.9F.E4.BA.A7.E8.80.85.E7.9A.84.E5.8F.AF.E9.9D.A0.E6.80.A7.E4.BF.9D.E8.AF.81"><span class="tocnumber">7.1.1</span> <span class="toctext">生产者的可靠性保证</span></a></li>
<li class="toclevel-3"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E6.9C.8D.E5.8A.A1.E5.99.A8.E7.9A.84.E5.8F.AF.E9.9D.A0.E6.80.A7.E4.BF.9D.E8.AF.81"><span class="tocnumber">7.1.2</span> <span class="toctext">服务器的可靠性保证</span></a></li>
<li class="toclevel-3"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E6.B6.88.E8.B4.B9.E8.80.85.E7.9A.84.E5.8F.AF.E9.9D.A0.E6.80.A7.E4.BF.9D.E8.AF.81"><span class="tocnumber">7.1.3</span> <span class="toctext">消费者的可靠性保证</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E9.A1.BA.E5.BA.8F"><span class="tocnumber">7.2</span> <span class="toctext">顺序</span></a></li>
<li class="toclevel-2"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E6.B6.88.E6.81.AF.E9.87.8D.E5.A4.8D"><span class="tocnumber">7.3</span> <span class="toctext">消息重复</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E9.9B.86.E7.BE.A4.E5.92.8C.E8.B4.9F.E8.BD.BD.E5.9D.87.E8.A1.A1"><span class="tocnumber">8</span> <span class="toctext">集群和负载均衡</span></a>
<ul>
<li class="toclevel-2"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E9.9B.86.E7.BE.A4"><span class="tocnumber">8.1</span> <span class="toctext">集群</span></a></li>
<li class="toclevel-2"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E8.B4.9F.E8.BD.BD.E5.9D.87.E8.A1.A1"><span class="tocnumber">8.2</span> <span class="toctext">负载均衡</span></a>
<ul>
<li class="toclevel-3"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E7.94.9F.E4.BA.A7.E8.80.85.E7.9A.84.E8.B4.9F.E8.BD.BD.E5.9D.87.E8.A1.A1.E5.92.8Cfailover"><span class="tocnumber">8.2.1</span> <span class="toctext">生产者的负载均衡和failover</span></a></li>
<li class="toclevel-3"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E6.B6.88.E8.B4.B9.E8.80.85.E7.9A.84.E8.B4.9F.E8.BD.BD.E5.9D.87.E8.A1.A1"><span class="tocnumber">8.2.2</span> <span class="toctext">消费者的负载均衡</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E6.9C.8D.E5.8A.A1.E5.99.A8.E9.83.A8.E7.BD.B2"><span class="tocnumber">9</span> <span class="toctext">服务器部署</span></a>
<ul>
<li class="toclevel-2"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E5.89.8D.E6.8F.90.EF.BC.9A.E5.AE.89.E8.A3.85zookeeper"><span class="tocnumber">9.1</span> <span class="toctext">前提：安装zookeeper</span></a></li>
<li class="toclevel-2"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E7.AC.AC.E4.BA.8C.E6.AD.A5.EF.BC.9A.E9.85.8D.E7.BD.AEserver.ini"><span class="tocnumber">9.2</span> <span class="toctext">第二步：配置server.ini</span></a></li>
<li class="toclevel-2"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E7.AC.AC.E4.B8.89.E6.AD.A5.EF.BC.9A.E5.90.AF.E5.8A.A8.E6.9C.8D.E5.8A.A1.E5.99.A8"><span class="tocnumber">9.3</span> <span class="toctext">第三步：启动服务器</span></a></li>
<li class="toclevel-2"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E5.85.B3.E9.97.AD.E6.9C.8D.E5.8A.A1.E5.99.A8"><span class="tocnumber">9.4</span> <span class="toctext">关闭服务器</span></a></li>
<li class="toclevel-2"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E6.9C.8D.E5.8A.A1.E5.99.A8.E7.9A.84.E5.BF.AB.E9.80.9F.E5.90.AF.E5.8A.A8"><span class="tocnumber">9.5</span> <span class="toctext">服务器的快速启动</span></a></li>
<li class="toclevel-2"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E6.B6.88.E6.81.AF.E7.9A.84.E5.88.A0.E9.99.A4.E7.AD.96.E7.95.A5"><span class="tocnumber">9.6</span> <span class="toctext">消息的删除策略</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E6.9C.80.E4.BD.B3.E5.AE.9E.E8.B7.B5"><span class="tocnumber">10</span> <span class="toctext">最佳实践</span></a>
<ul>
<li class="toclevel-2"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E5.AE.A2.E6.88.B7.E7.AB.AF.E6.9C.80.E4.BD.B3.E5.AE.9E.E8.B7.B5"><span class="tocnumber">10.1</span> <span class="toctext">客户端最佳实践</span></a></li>
<li class="toclevel-2"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E7.94.9F.E4.BA.A7.E8.80.85.E6.9C.80.E4.BD.B3.E5.AE.9E.E8.B7.B5"><span class="tocnumber">10.2</span> <span class="toctext">生产者最佳实践</span></a></li>
<li class="toclevel-2"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E6.B6.88.E8.B4.B9.E8.80.85.E7.9A.84.E6.9C.80.E4.BD.B3.E5.AE.9E.E8.B7.B5"><span class="tocnumber">10.3</span> <span class="toctext">消费者的最佳实践</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E5.8E.9F.E7.90.86.E5.92.8C.E5.AE.9E.E7.8E.B0"><span class="tocnumber">11</span> <span class="toctext">原理和实现</span></a>
<ul>
<li class="toclevel-2"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E8.AE.BE.E8.AE.A1.E5.8E.9F.E7.90.86"><span class="tocnumber">11.1</span> <span class="toctext">设计原理</span></a></li>
<li class="toclevel-2"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E7.BD.91.E7.BB.9C.E9.80.9A.E8.AE.AF.E5.92.8C.E5.8D.8F.E8.AE.AE"><span class="tocnumber">11.2</span> <span class="toctext">网络通讯和协议</span></a></li>
<li class="toclevel-2"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E6.B6.88.E6.81.AF.E7.9A.84.E5.AD.98.E5.82.A8.E7.BB.93.E6.9E.84"><span class="tocnumber">11.3</span> <span class="toctext">消息的存储结构</span></a></li>
<li class="toclevel-2"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E6.B6.88.E6.81.AF.E7.9A.84.E6.81.A2.E5.A4.8D.E5.92.8C.E9.87.8D.E8.AF.95"><span class="tocnumber">11.4</span> <span class="toctext">消息的恢复和重试</span></a></li>
<li class="toclevel-2"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#HA.E5.BC.82.E6.AD.A5.E5.A4.8D.E5.88.B6.E6.96.B9.E6.A1.88"><span class="tocnumber">11.5</span> <span class="toctext">HA异步复制方案</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#FAQ"><span class="tocnumber">12</span> <span class="toctext">FAQ</span></a>
<ul>
<li class="toclevel-2"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E9.87.87.E7.94.A8pull.E6.A8.A1.E5.9E.8B.EF.BC.8C.E6.B6.88.E6.81.AF.E7.9A.84.E5.AE.9E.E6.97.B6.E6.80.A7.E6.9C.89.E4.BF.9D.E8.AF.81.E5.90.97.EF.BC.9F"><span class="tocnumber">12.1</span> <span class="toctext">采用pull模型，消息的实时性有保证吗？</span></a></li>
<li class="toclevel-2"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#Metaq.E6.80.8E.E4.B9.88.E5.81.9A.E5.88.B0.E7.8E.AF.E5.A2.83.E9.9A.94.E7.A6.BB.EF.BC.9F"><span class="tocnumber">12.2</span> <span class="toctext">Metaq怎么做到环境隔离？</span></a></li>
<li class="toclevel-2"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E5.B8.B8.E8.A7.81.E9.94.99.E8.AF.AF.E5.8F.8A.E5.A4.84.E7.90.86.E5.8A.9E.E6.B3.95"><span class="tocnumber">12.3</span> <span class="toctext">常见错误及处理办法</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E6.B6.88.E6.81.AF.E8.BF.87.E6.BB.A4"><span class="tocnumber">13</span> <span class="toctext">消息过滤</span></a>
<ul>
<li class="toclevel-2"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E5.AE.9E.E7.8E.B0.E5.8E.9F.E7.90.86"><span class="tocnumber">13.1</span> <span class="toctext">实现原理</span></a></li>
<li class="toclevel-2"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E7.A4.BA.E4.BE.8B.E4.BB.A3.E7.A0.81"><span class="tocnumber">13.2</span> <span class="toctext">示例代码</span></a></li>
<li class="toclevel-2"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E6.B3.A8.E6.84.8F.E4.BA.8B.E9.A1.B9"><span class="tocnumber">13.3</span> <span class="toctext">注意事项</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E9.99.84.E5.BD.95.E4.BF.A1.E6.81.AF"><span class="tocnumber">14</span> <span class="toctext">附录信息</span></a></li>
</ul>
</td></tr></tbody></table><script type="text/javascript"> if (window.showTocToggle) { var tocShowText = "显示"; var tocHideText = "隐藏"; showTocToggle(); } </script>
<a name=".E7.89.88.E6.9C.AC" id=".E7.89.88.E6.9C.AC"></a><h2> <span class="mw-headline"> 版本  </span></h2>
<ol><li>0.1版本，针对Metaq 1.0版本
</li><li>0.2版本，针对Metaq 1.2版本
</li></ol>
<a name=".E7.AE.80.E4.BB.8B" id=".E7.AE.80.E4.BB.8B"></a><h2> <span class="mw-headline"> 简介  </span></h2>
<p>Memorphosis是一个消息中间件，它是linkedin开源MQ——<a href="http://sna-projects.com/kafka/" class="external text" title="http://sna-projects.com/kafka/" target="_blank" rel="nofollow">kafka</a>的Java版本，针对淘宝内部应用做了定制和优化。Metaq的设计原则
</p>
<ul><li>消息都是持久的，保存在磁盘
</li><li>吞吐量第一
</li><li>消费状态保存在客户端
</li><li>分布式，生产者、服务器和消费者都可分布
</li></ul>
<p>Metaq的部署结构
</p><p><a href="http://baike.corp.taobao.com/index.php/File:Meta%E9%83%A8%E7%BD%B2%E7%BB%93%E6%9E%84.png" class="image" title="Image:Meta部署结构.png"><img alt="Image:Meta部署结构.png" src="./userguide_files/Meta部署结构.png" width="751" height="502" border="0"></a>
</p><p><br>
</p>
<a name="Metaq.E7.9A.84.E7.89.B9.E7.82.B9" id="Metaq.E7.9A.84.E7.89.B9.E7.82.B9"></a><h2> <span class="mw-headline"> Metaq的特点  </span></h2>
<p>除了完整实现kafka的功能之外，我们还为meta加入了额外的功能，使得meta成为一个更为强大的通用消息中间件，包括
</p>
<ul><li>彻底用java重写的实现，高效的协议和通讯框架
</li><li>发送端的负载均衡
</li><li>Master/Slave异步复制的高可用方案
</li><li>专门用于广播消息的客户端实现
</li><li>与diamond结合使用的顺序发送消息功能
</li><li>支持事务，包括本地事务和分布式事务，实现JTA规范。
</li></ul>
<a name="Getting_started" id="Getting_started"></a><h2> <span class="mw-headline"> Getting started  </span></h2>
<p>我们在日常已经部署了metamorhposis环境，因此你可以直接在本地测试，如果你想部署一个自己的服务器，可以参照<a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E6.9C.8D.E5.8A.A1.E5.99.A8.E9.83.A8.E7.BD.B2" title="">#.E6.9C.8D.E5.8A.A1.E5.99.A8.E9.83.A8.E7.BD.B2</a>节。
</p><p>前面提到，meta是一个消息中间件。消息中间件中有两个角色：消息生产者和消息消费者。Meta里同样有这两个概念，消息生产者负责创建消息并发送到meta服务器，meta服务器会将消息持久化到磁盘，消息消费者从meta服务器拉取消息并提交给应用消费。
</p><p><br>
</p>
<a name=".E6.B6.88.E6.81.AF.E4.BC.9A.E8.AF.9D.E5.B7.A5.E5.8E.82.E7.B1.BB" id=".E6.B6.88.E6.81.AF.E4.BC.9A.E8.AF.9D.E5.B7.A5.E5.8E.82.E7.B1.BB"></a><h3> <span class="mw-headline"> 消息会话工厂类  </span></h3>
<p>在使用消息生产者和消费者之前，我们需要创建它们，这就需要用到消息会话工厂类——<a href="http://10.232.102.184:3000/apidocs/com/taobao/Metaq/client/MessageSessionFactory.html" class="external text" title="http://10.232.102.184:3000/apidocs/com/taobao/Metaq/client/MessageSessionFactory.html" target="_blank" rel="nofollow">MessageSessionFactory</a>，由这个工厂帮你创建生产者或者消费者。除了这些，<a href="http://10.232.102.184:3000/apidocs/com/taobao/Metaq/client/MessageSessionFactory.html" class="external text" title="http://10.232.102.184:3000/apidocs/com/taobao/Metaq/client/MessageSessionFactory.html" target="_blank" rel="nofollow">MessageSessionFactory</a>还默默无闻地在后面帮你做很多事情，包括
</p>
<ol><li>服务的查找和发现，通过diamond和zookeeper帮你查找日常的meta服务器地址列表
</li><li>连接的创建和销毁，自动创建和销毁到meta服务器的连接，并做连接复用，也就是到同一台meta的服务器在一个工厂内只维持一个连接。
</li><li>消息消费者的消息存储和恢复，后续我们会谈到这一点。
</li><li>协调和管理各种资源，包括创建的生产者和消费者的。
</li></ol>
<p>因此，我们首先需要创建一个会话工厂类，<a href="http://10.232.102.184:3000/apidocs/com/taobao/Metaq/client/MessageSessionFactory.html" class="external text" title="http://10.232.102.184:3000/apidocs/com/taobao/Metaq/client/MessageSessionFactory.html" target="_blank" rel="nofollow">MessageSessionFactory</a>仅是一个接口，它的实现类是MetaMessageSessionFactory
</p>
<pre>MessageSessionFactory sessionFactory = new MetaMessageSessionFactory(new MetaClientConfig());
</pre>
<p><b>请注意,MessageSessionFactory应当全局共用一个</b>
</p>
<a name=".E6.B6.88.E6.81.AF.E7.94.9F.E4.BA.A7.E8.80.85" id=".E6.B6.88.E6.81.AF.E7.94.9F.E4.BA.A7.E8.80.85"></a><h3> <span class="mw-headline"> 消息生产者  </span></h3>
<p>翠花，上代码
</p>
<pre>package com.taobao.Metaq.example;

import java.io.BufferedReader;
import java.io.InputStreamReader;

import com.taobao.Metaq.Message;
import com.taobao.Metaq.client.MessageSessionFactory;
import com.taobao.Metaq.client.MetaClientConfig;
import com.taobao.Metaq.client.MetaMessageSessionFactory;
import com.taobao.Metaq.client.producer.MessageProducer;
import com.taobao.Metaq.client.producer.SendResult;


public class Producer {
    public static void main(String[] args) throws Exception {
        // New session factory
        MessageSessionFactory sessionFactory = new MetaMessageSessionFactory(new MetaClientConfig());
        // create producer
        MessageProducer producer = sessionFactory.createProducer();
        // publish topic
        final String topic = "meta-test";
        producer.publish(topic);

        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String line = null;
        while ((line = reader.readLine())&nbsp;!= null) {
            // send message
            SendResult sendResult = producer.sendMessage(new Message(topic, line.getBytes()));
            // check result
            if (!sendResult.isSuccess()) {
                System.err.println("Send message failed,error message:" + sendResult.getErrorMessage());
            }
            else {
                System.out.println("Send message successfully,sent to " + sendResult.getPartition());
            }
        }
    }

}
</pre>
<p>消息生产者的接口是<a href="http://10.232.102.184:3000/apidocs/com/taobao/Metaq/client/producer/MessageProducer.html" class="external text" title="http://10.232.102.184:3000/apidocs/com/taobao/Metaq/client/producer/MessageProducer.html" target="_blank" rel="nofollow">MessageProducer</a>，你可以通过它来发送消息。创建生产者很简单，通过MessageSessionFactory的createProducer方法即可以创建一个生产者。在Meta里，每个消息对象都是Message类的实例，Message表示一个消息对象，它包含这么几个属性：
</p>
<table border="1" cellspacing="0" cellpadding="5">

<tbody><tr>
<th> 属性
</th><th> 值
</th></tr>
<tr>
<td> id
</td><td> 消息的唯一id，系统自动产生，用户无法设置，在发送成功后由服务器返回，发送失败则为0。
</td></tr>
<tr>
<td> topic
</td><td> 消息的主题，订阅者订阅该主题即可接收发送到该主题下的消息，必须
</td></tr>
<tr>
<td> data
</td><td> 消息的有效载荷，也就是消息内容，meta永远不会修改消息内容，你发送出去是什么样子，接收到就是什么样子。消息内容限制在1M以内，我的建议是最好不要发送超过上百K的消息，必须
</td></tr>
<tr>
<td> attribute
</td><td> 消息属性，一个字符串，可选。发送者可设置消息属性来让消费者过滤。
</td></tr></tbody></table>
<p><br> 细心的朋友可能注意到，我们在sendMessage之前还调用了<a href="http://10.232.102.184:3000/apidocs/com/taobao/Metaq/client/producer/MessageProducer.html" class="external text" title="http://10.232.102.184:3000/apidocs/com/taobao/Metaq/client/producer/MessageProducer.html" target="_blank" rel="nofollow">MessageProducer</a>的publish(topic)方法
</p>
<pre>producer.publish(topic);
</pre>
<p>这一步在发送消息前是<b>必须</b>的，你必须发布你将要发送消息的topic，这是为了让会话工厂帮你去查找接收这些topic的meta服务器地址并初始化连接。这个步骤针对每个topic只需要做一次，多次调用无影响。
</p><p>总结下这个例子，从标准输入读入你输入的数据，并将数据封装成一个Message对象，发送到topic为meta-test下。
</p><p>请注意，<b>MessageProducer是线程安全的，完全可重复使用，因此最好在应用中作为单例来使用，一次创建，到处使用，配置为spring里的singleton bean。MessageProducer创建的代价昂贵，每次都需要通过zk查找服务器并创建tcp长连接。</b>
</p>
<a name=".E6.B6.88.E6.81.AF.E6.B6.88.E8.B4.B9.E8.80.85" id=".E6.B6.88.E6.81.AF.E6.B6.88.E8.B4.B9.E8.80.85"></a><h3> <span class="mw-headline"> 消息消费者  </span></h3>
<p>发送消息后，消费者可以接收消息了，下面的代码创建消费者并订阅meta-test这个主题，等待消息送达并打印消息内容
</p>
<pre>package com.taobao.Metaq.example;

import java.util.concurrent.Executor;

import com.taobao.Metaq.Message;
import com.taobao.Metaq.client.MessageSessionFactory;
import com.taobao.Metaq.client.MetaClientConfig;
import com.taobao.Metaq.client.MetaMessageSessionFactory;
import com.taobao.Metaq.client.consumer.ConsumerConfig;
import com.taobao.Metaq.client.consumer.MessageConsumer;
import com.taobao.Metaq.client.consumer.MessageListener;

public class AsyncConsumer {
    public static void main(String[] args) throws Exception {
        // New session factory
        MessageSessionFactory sessionFactory = new MetaMessageSessionFactory(new MetaClientConfig());
        // subscribed topic
        final String topic = "meta-test";
        // consumer group
        final String group = "meta-example";
        // create consumer
        MessageConsumer consumer = sessionFactory.createConsumer(new ConsumerConfig(group));
        // subscribe topic
        consumer.subscribe(topic, 1024 * 1024, new MessageListener() {

            public void recieveMessages(Message message) {
                System.out.println("Receive message " + new String(message.getData()));
            }


            public Executor getExecutor() {
                // Thread pool to process messages,maybe null.
                return null;
            }
        });
        // complete subscribe
        consumer.completeSubscribe();

    }

}
</pre>
<p>通过createConsumer方法来创建<a href="http://10.232.102.184:3000/apidocs/com/taobao/Metaq/client/consumer/MessageConsumer.html" class="external text" title="http://10.232.102.184:3000/apidocs/com/taobao/Metaq/client/consumer/MessageConsumer.html" target="_blank" rel="nofollow">MessageConsumer</a>，注意到我们传入一个<a href="http://10.232.102.184:3000/apidocs/com/taobao/Metaq/client/consumer/ConsumerConfig.html" class="external text" title="http://10.232.102.184:3000/apidocs/com/taobao/Metaq/client/consumer/ConsumerConfig.html" target="_blank" rel="nofollow">ConsumerConfig</a>参数，这是消费者的配置对象。每个消息者都必须有一个<a href="http://10.232.102.184:3000/apidocs/com/taobao/Metaq/client/consumer/ConsumerConfig.html" class="external text" title="http://10.232.102.184:3000/apidocs/com/taobao/Metaq/client/consumer/ConsumerConfig.html" target="_blank" rel="nofollow">ConsumerConfig</a>配置对象，我们这里只设置了group属性，这是消费者的分组名称。Meta的Producer、Consumer和Broker都可以为集群。消费者可以组成一个集群共同消费同一个topic，发往这个topic的消息将按照一定的负载均衡规则发送给集群里的一台机器。同一个消费者集群必须拥有同一个分组名称，也就是同一个group，这个概念跟notify里的订阅者组名是一样的。我们这里将分组名称设置为meta-example。
</p><p>订阅消息通过subscribe方法，这个方法接受三个参数
</p>
<ul><li>topic，订阅的主题
</li><li>maxSize，因为meta是一个消费者主动拉取的模型，这个参数规定每次拉取的最大数据量，单位为字节，这里设置为1M，最大为1M。
</li><li>MessageListener，消息监听器，负责消费消息。
</li></ul>
<p><a href="http://10.232.102.184:3000/apidocs/com/taobao/Metaq/client/consumer/MessageListener.html" class="external text" title="http://10.232.102.184:3000/apidocs/com/taobao/Metaq/client/consumer/MessageListener.html" target="_blank" rel="nofollow">MessageListener</a>的接口方法如下
</p>
<pre>public interface MessageListener {
    /**
     * 接收到消息列表，只有messages不为空并且不为null的情况下会触发此方法
     *
     * @param messages
     */
    public void recieveMessages(Message message);


    /**
     * 处理消息的线程池
     *
     * @return
     */
    public Executor getExecutor();
}

</pre>
<p>消息的消费过程可以是一个并发处理的过程，getExecutor返回你想设置的线程池，每次消费都会在这个线程池里进行。recieveMessage方法用于实际的消息消费处理，message参数即为消费者收到的消息，它必不为null。
</p><p>我们这里简单地打印收到的消息内容就完成消费。如果在消费过程中抛出任何异常，该条消息将会在一定间隔后重新尝试提交给MessageListener消费。在多次消费失败的情况下，该消息将会存储到消费者应用的本次磁盘，并在后台自动恢复重试消费。
</p><p>细心的你一定还注意到，在调用subscribe之后，我们还调用了completeSubscribe方法来完成订阅过程。请注意，<b>subscribe仅是将订阅信息保存在本地，并没有实际跟meta服务器交互，要使得订阅关系生效必须调用一次completeSubscribe，completeSubscribe仅能被调用一次，多次调用将抛出异常</b>。 为什么需要completeSubscribe方法呢，原因有二：
</p>
<ul><li>首先，subscribe方法可以被调用多次，也就是一个消费者可以消费多种topic
</li><li>其次，如果每次调用subscribe都跟zk和meta服务器交互一次，代价太高
</li></ul>
<p>因此completeSubscribe一次性将所有订阅的topic生效，并处理跟zk和meta服务器交互的所有过程。
</p><p>同样,<b>MessageConsumer也是线程安全的，创建的代价不低，因此也应该尽量复用。</b>
</p>
<a name=".E4.BE.8B.E5.AD.90.E5.B0.8F.E7.BB.93" id=".E4.BE.8B.E5.AD.90.E5.B0.8F.E7.BB.93"></a><h3> <span class="mw-headline"> 例子小结  </span></h3>
<p>上面的例子可以直接在您的机器上跑起来，因为我们在日常已经部署了几台meta机器。不过我们建议您测试的时候使用自己的topic和消费者组名group，防止跟其他测试的开发者产生冲突，如有疑问，可以联系伯岩(boyan@taobao.com),无花(wuhua@taobao.com),
</p><p>此例子的代码可以在Metaq-example工程下找到，Metaq-example源码的svn地址
</p><p><a href="http://svn.app.taobao.net/repos/metaq/trunk/metaq/metaq-example" class="external free" title="http://svn.app.taobao.net/repos/metaq/trunk/metaq/metaq-example" target="_blank" rel="nofollow">http://svn.app.taobao.net/repos/metaq/trunk/metaq/metaq-example</a>
</p><p>你可以在这里找到所有meta的例子源码。
</p>
<a name=".E4.BA.8B.E5.8A.A1" id=".E4.BA.8B.E5.8A.A1"></a><h2> <span class="mw-headline"> 事务  </span></h2>
<p>Metaq 1.2开始支持事务，包括发送端和消费端事务。发送端同时支持本地事务和分布式事务，可以在一个事务内发送多条消息，要么同时成功，要么同时失败；可以使用XA事务，在事务内操作其他XA资源，例如操作数据库，与此同时发送meta消息，可以保证这些操作和发送消息要么一起成功，要么一起失败。
</p><p>在消费消息的时候，可以批量消费一批消息，要么一起消费成功，要么失败重试。
</p>
<a name=".E5.8F.91.E9.80.81.E6.B6.88.E6.81.AF.E7.9A.84.E6.9C.AC.E5.9C.B0.E4.BA.8B.E5.8A.A1" id=".E5.8F.91.E9.80.81.E6.B6.88.E6.81.AF.E7.9A.84.E6.9C.AC.E5.9C.B0.E4.BA.8B.E5.8A.A1"></a><h3> <span class="mw-headline"> 发送消息的本地事务  </span></h3>
<p>事务跟线程关联，启动一个事务将会关联该事务到当前线程，在此线程和此事务内发送的消息，将作为一个整体发送，同时成功，或者同时失败，对外界看来是一个原子操作。发起一个本地事务很简单，参见代码：
</p>
<pre>       try {
                // 开始事务
                producer.beginTransaction();
                // 在事务内发送两条消息
                if (!producer.sendMessage(new Message(topic, line.getBytes())).isSuccess()) {
                    // 发送失败，立即回滚
                    producer.rollback();
                    continue;
                }
                if (!producer.sendMessage(new Message(topic, line.getBytes())).isSuccess()) {
                    producer.rollback();
                    continue;
                }
                // 提交
                producer.commit();

            }
            catch (final Exception e) {
                producer.rollback();
            }
</pre>
<p>beginTransaction方法启动一个事务并关联到当前线程，commit方法提交事务，而rollback则回滚当前事务。
</p>
<a name=".E5.8F.91.E9.80.81.E6.B6.88.E6.81.AF.E7.9A.84.E5.88.86.E5.B8.83.E5.BC.8F.E4.BA.8B.E5.8A.A1" id=".E5.8F.91.E9.80.81.E6.B6.88.E6.81.AF.E7.9A.84.E5.88.86.E5.B8.83.E5.BC.8F.E4.BA.8B.E5.8A.A1"></a><h3> <span class="mw-headline"> 发送消息的分布式事务  </span></h3>
<p>如果你要在发送消息的同时操作数据库，比如同时将消息插入某张表，例如下订单的时候同时发送消息通知卖家并将订单插入数据库，这时候因为涉及到两个Resource（数据库和meta)，就需要使用分布式事务来保证ACID。分布式事务一般采用两阶段提交协议，在java里就是使用JTA规范API的XA部分。
</p><p>在这种情形下，你需要使用数据库的XADatasource和meta的XAMessageProducer类，并使用一个开源JTA实现来支持事务管理器做协调者。例如我们在Metaq-example里的XATransactionProducer例子使用了atomikos这个开源JTA实现，具体不在这里讲解，请直接参考源码并尝试运行。
</p><p><br>
</p>
<a name=".E6.B6.88.E8.B4.B9.E8.80.85.E7.9A.84.E4.BA.8B.E5.8A.A1" id=".E6.B6.88.E8.B4.B9.E8.80.85.E7.9A.84.E4.BA.8B.E5.8A.A1"></a><h3> <span class="mw-headline"> 消费者的事务  </span></h3>
<p>参见 TransactionalConsumer 例子。
</p>
<a name=".E6.A6.82.E5.BF.B5.E5.92.8CAPI.E8.AF.A6.E8.A7.A3" id=".E6.A6.82.E5.BF.B5.E5.92.8CAPI.E8.AF.A6.E8.A7.A3"></a><h2> <span class="mw-headline"> 概念和API详解  </span></h2>
<a name=".E6.9C.AF.E8.AF.AD.E8.A7.A3.E9.87.8A" id=".E6.9C.AF.E8.AF.AD.E8.A7.A3.E9.87.8A"></a><h3> <span class="mw-headline"> 术语解释  </span></h3>
<a name=".E6.B6.88.E6.81.AF.E7.94.9F.E4.BA.A7.E8.80.85_2" id=".E6.B6.88.E6.81.AF.E7.94.9F.E4.BA.A7.E8.80.85_2"></a><h4> <span class="mw-headline"> 消息生产者  </span></h4>
<p>也称为Message Producer，一般简称为producer，负责产生消息并发送消息到meta服务器。
</p>
<a name=".E6.B6.88.E6.81.AF.E6.B6.88.E8.B4.B9.E8.80.85_2" id=".E6.B6.88.E6.81.AF.E6.B6.88.E8.B4.B9.E8.80.85_2"></a><h4> <span class="mw-headline"> 消息消费者  </span></h4>
<p>也称为Message Consumer，一般简称为consumer，负责消息的消费，meta采用pull模型，由消费者主动从meta服务器拉取数据并解析成消息并消费。
</p>
<a name="Topic" id="Topic"></a><h4> <span class="mw-headline"> Topic  </span></h4>
<p>消息的主题，由用户定义并在服务端配置。producer发送消息到某个topic下，consumer从某个topic下消费消息。
</p>
<a name=".E5.88.86.E5.8C.BA.28partition.29" id=".E5.88.86.E5.8C.BA.28partition.29"></a><h4> <span class="mw-headline"> 分区(partition)  </span></h4>
<p>同一个topic下面还分为多个分区，如meta-test这个topic我们可以分为10个分区，分别有两台服务器提供，那么可能每台服务器提供5个分区，假设服务器分别为0和1，则所有分区为0-0、0-1、0-2、0-3、0-4、1-0、1-1、1-2、1-3、1-4。
</p><p>分区跟消费者的负载均衡机制有很大关系，具体见<a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E6.B6.88.E8.B4.B9.E8.80.85.E7.9A.84.E8.B4.9F.E8.BD.BD.E5.9D.87.E8.A1.A1" title="">#.E6.B6.88.E8.B4.B9.E8.80.85.E7.9A.84.E8.B4.9F.E8.BD.BD.E5.9D.87.E8.A1.A1</a>。
</p>
<a name="Message" id="Message"></a><h4> <span class="mw-headline"> Message  </span></h4>
<p>消息，负载用户数据并在生产者、服务端和消费者之间传输。
</p>
<a name="Broker" id="Broker"></a><h4> <span class="mw-headline"> Broker  </span></h4>
<p>就是meta的服务端或者说服务器，在消息中间件中也通常称为broker。
</p>
<a name=".E6.B6.88.E8.B4.B9.E8.80.85.E5.88.86.E7.BB.84.28Group.29" id=".E6.B6.88.E8.B4.B9.E8.80.85.E5.88.86.E7.BB.84.28Group.29"></a><h4> <span class="mw-headline"> 消费者分组(Group)  </span></h4>
<p>消费者可以是多个消费者共同消费一个topic下的消息，每个消费者消费部分消息。这些消费者就组成一个分组，拥有同一个分组名称,通常也称为消费者集群
</p>
<a name="Offset" id="Offset"></a><h4> <span class="mw-headline"> Offset  </span></h4>
<p>消息在broker上的每个分区都是组织成一个文件列表，消费者拉取数据需要知道数据在文件中的偏移量，这个偏移量就是所谓offset。Offset是绝对偏移量，服务器会将offset转化为具体文件的相对偏移量。详细内容参见<a href="http://baike.corp.taobao.com/index.php/Metaq-User-Guide#.E6.B6.88.E6.81.AF.E7.9A.84.E5.AD.98.E5.82.A8.E7.BB.93.E6.9E.84" title="">#.E6.B6.88.E6.81.AF.E7.9A.84.E5.AD.98.E5.82.A8.E7.BB.93.E6.9E.84</a>
</p>
<a name=".E5.AE.A2.E6.88.B7.E7.AB.AFAPI" id=".E5.AE.A2.E6.88.B7.E7.AB.AFAPI"></a><h3> <span class="mw-headline"> 客户端API  </span></h3>
<a name="MessageSessionFactory.E6.8E.A5.E5.8F.A3" id="MessageSessionFactory.E6.8E.A5.E5.8F.A3"></a><h4> <span class="mw-headline"> MessageSessionFactory接口  </span></h4>
<p>参见javadoc <a href="http://10.232.102.184:3000/apidocs/com/taobao/Metaq/client/MessageSessionFactory.html" class="external text" title="http://10.232.102.184:3000/apidocs/com/taobao/Metaq/client/MessageSessionFactory.html" target="_blank" rel="nofollow">MessageSessionFactory</a>
</p><p>主要实现类 <a href="http://10.232.102.184:3000/apidocs/com/taobao/Metaq/client/MetaMessageSessionFactory.html" class="external text" title="http://10.232.102.184:3000/apidocs/com/taobao/Metaq/client/MetaMessageSessionFactory.html" target="_blank" rel="nofollow">MetaMessageSessionFactory</a>
</p>
<a name="MessageProducer.E6.8E.A5.E5.8F.A3" id="MessageProducer.E6.8E.A5.E5.8F.A3"></a><h4> <span class="mw-headline"> MessageProducer接口  </span></h4>
<p>参见javadoc <a href="http://10.232.102.184:3000/apidocs/com/taobao/Metaq/client/producer/MessageProducer.html" class="external text" title="http://10.232.102.184:3000/apidocs/com/taobao/Metaq/client/producer/MessageProducer.html" target="_blank" rel="nofollow">MessageProducer</a>
</p><p>主要实现类 <a href="http://10.232.102.184:3000/apidocs/com/taobao/Metaq/client/producer/SimpleMessageProducer.html" class="external text" title="http://10.232.102.184:3000/apidocs/com/taobao/Metaq/client/producer/SimpleMessageProducer.html" target="_blank" rel="nofollow">SimpleMessageProducer</a>
</p>
<a name="PartitionSelector.E6.8E.A5.E5.8F.A3" id="PartitionSelector.E6.8E.A5.E5.8F.A3"></a><h5> <span class="mw-headline"> PartitionSelector接口  </span></h5>
<p>分区选择器，用于从分区列表中选中将要发送消息的分区，参见javadoc <a href="http://10.232.102.184:3000/apidocs/com/taobao/Metaq/client/producer/PartitionSelector.html" class="external text" title="http://10.232.102.184:3000/apidocs/com/taobao/Metaq/client/producer/PartitionSelector.html" target="_blank" rel="nofollow">PartitionSelector</a>
</p><p>主要实现类，轮询分区选择器 <a href="http://10.232.102.184:3000/apidocs/com/taobao/Metaq/client/producer/RoundRobinPartitionSelector.html" class="external text" title="http://10.232.102.184:3000/apidocs/com/taobao/Metaq/client/producer/RoundRobinPartitionSelector.html" target="_blank" rel="nofollow">RoundRobinPartitionSelector</a>
</p><p>客户端可自定义分区选择器，并在创建生产者的时候注入。
</p>
<a name="SendResult.E7.B1.BB" id="SendResult.E7.B1.BB"></a><h5> <span class="mw-headline"> SendResult类  </span></h5>
<p>发送结果信息,参见javadoc <a href="http://10.232.102.184:3000/apidocs/com/taobao/Metaq/client/producer/SendResult.html" class="external text" title="http://10.232.102.184:3000/apidocs/com/taobao/Metaq/client/producer/SendResult.html" target="_blank" rel="nofollow">SendResult</a>
</p>
<a name="MessageConsumer.E6.8E.A5.E5.8F.A3" id="MessageConsumer.E6.8E.A5.E5.8F.A3"></a><h4> <span class="mw-headline"> MessageConsumer接口  </span></h4>
<p>参见javadoc <a href="http://10.232.102.184:3000/apidocs/com/taobao/Metaq/client/consumer/MessageConsumer.html" class="external text" title="http://10.232.102.184:3000/apidocs/com/taobao/Metaq/client/consumer/MessageConsumer.html" target="_blank" rel="nofollow">MessageConsumer</a> 主要实现类 <a href="http://10.232.102.184:3000/apidocs/com/taobao/Metaq/client/consumer/SimpleMessageConsumer.html" class="external text" title="http://10.232.102.184:3000/apidocs/com/taobao/Metaq/client/consumer/SimpleMessageConsumer.html" target="_blank" rel="nofollow">SimpleMessageConsumer</a>
</p>
<a name="MessageListener.E6.8E.A5.E5.8F.A3" id="MessageListener.E6.8E.A5.E5.8F.A3"></a><h5> <span class="mw-headline"> MessageListener接口  </span></h5>
<p>消息监听器，处理消费消息，参见javadoc <a href="http://10.232.102.184:3000/apidocs/com/taobao/Metaq/client/consumer/MessageListener.html" class="external text" title="http://10.232.102.184:3000/apidocs/com/taobao/Metaq/client/consumer/MessageListener.html" target="_blank" rel="nofollow">MessageListener</a>
</p>
<a name="OffsetStorage.E6.8E.A5.E5.8F.A3" id="OffsetStorage.E6.8E.A5.E5.8F.A3"></a><h5> <span class="mw-headline"> OffsetStorage接口  </span></h5>
<p>Offset存储器，参见javadoc <a href="http://10.232.102.184:3000/apidocs/com/taobao/Metaq/client/consumer/storage/OffsetStorage.html" class="external text" title="http://10.232.102.184:3000/apidocs/com/taobao/Metaq/client/consumer/storage/OffsetStorage.html" target="_blank" rel="nofollow">OffsetStorage</a>，用户可自定义实现自己的存储器，默认提供下列三种存储器
</p>
<ol><li><a href="http://10.232.102.184:3000/apidocs/com/taobao/Metaq/client/consumer/storage/ZkOffsetStorage.html" class="external text" title="http://10.232.102.184:3000/apidocs/com/taobao/Metaq/client/consumer/storage/ZkOffsetStorage.html" target="_blank" rel="nofollow">ZkOffsetStorage</a>,存储在zookeeper
</li><li><a href="http://10.232.102.184:3000/apidocs/com/taobao/Metaq/client/consumer/storage/MysqlOffsetStorage.html" class="external text" title="http://10.232.102.184:3000/apidocs/com/taobao/Metaq/client/consumer/storage/MysqlOffsetStorage.html" target="_blank" rel="nofollow">MysqlOffsetStorage</a>，存储在mysql数据库
</li><li><a href="http://10.232.102.184:3000/apidocs/com/taobao/Metaq/client/consumer/storage/LocalOffsetStorage.html" class="external text" title="http://10.232.102.184:3000/apidocs/com/taobao/Metaq/client/consumer/storage/LocalOffsetStorage.html" target="_blank" rel="nofollow">LocalOffsetStorage</a>，存储在本地文件，适合消费者分组只有一个消费者的情况，无需共享offset信息。
</li></ol>
<a name=".E5.8F.AF.E9.9D.A0.E6.80.A7.E3.80.81.E9.A1.BA.E5.BA.8F.E5.92.8C.E9.87.8D.E5.A4.8D" id=".E5.8F.AF.E9.9D.A0.E6.80.A7.E3.80.81.E9.A1.BA.E5.BA.8F.E5.92.8C.E9.87.8D.E5.A4.8D"></a><h2> <span class="mw-headline"> 可靠性、顺序和重复  </span></h2>
<a name=".E5.8F.AF.E9.9D.A0.E6.80.A7" id=".E5.8F.AF.E9.9D.A0.E6.80.A7"></a><h3> <span class="mw-headline"> 可靠性  </span></h3>
<p>Metaq的可靠性保证贯穿客户端和服务器。
</p>
<a name=".E7.94.9F.E4.BA.A7.E8.80.85.E7.9A.84.E5.8F.AF.E9.9D.A0.E6.80.A7.E4.BF.9D.E8.AF.81" id=".E7.94.9F.E4.BA.A7.E8.80.85.E7.9A.84.E5.8F.AF.E9.9D.A0.E6.80.A7.E4.BF.9D.E8.AF.81"></a><h4> <span class="mw-headline"> 生产者的可靠性保证  </span></h4>
<p>消息生产者发送消息后返回SendResult，如果isSuccess返回为true,则表示消息已经<b>确认发送到服务器并被服务器接收存储</b>。整个发送过程是一个<b>同步</b>的过程。保证消息送达服务器并返回结果。
</p>
<a name=".E6.9C.8D.E5.8A.A1.E5.99.A8.E7.9A.84.E5.8F.AF.E9.9D.A0.E6.80.A7.E4.BF.9D.E8.AF.81" id=".E6.9C.8D.E5.8A.A1.E5.99.A8.E7.9A.84.E5.8F.AF.E9.9D.A0.E6.80.A7.E4.BF.9D.E8.AF.81"></a><h4> <span class="mw-headline"> 服务器的可靠性保证  </span></h4>
<p>消息生产者发送的消息，meta服务器收到后在做必要的校验和检查之后的第一件事就是<b>写入磁盘</b>，写入成功之后返回应答给生产者。因此，可以确认每条发送结果为成功的消息服务器都是写入磁盘的。
</p><p>写入磁盘，不意味着数据落到磁盘设备上，毕竟我们还隔着一层os，os对写有缓冲。Meta有两个特性来保证数据落到磁盘上
</p>
<ol><li>每1000条（可配置），即强制调用一次force来写入磁盘设备。
</li><li>每隔10秒（可配置），强制调用一次force来写入磁盘设备。
</li></ol>
<p>因此,Meta通过配置可保证在异常情况下（如磁盘掉电）10秒内最多丢失1000条消息。
</p><p>服务器通常组织为一个集群，一条从生产者过来的消息可能按照路由规则存储到集群中的某台机器。Meta还正在实现高可用的HA方案，类似mysql的异步复制，将一台meta服务器的数据完整复制到另一台slave服务器，并且slave服务器还提供消费功能，本方案正在实现中，敬请期待。
</p><p><br>
</p>
<a name=".E6.B6.88.E8.B4.B9.E8.80.85.E7.9A.84.E5.8F.AF.E9.9D.A0.E6.80.A7.E4.BF.9D.E8.AF.81" id=".E6.B6.88.E8.B4.B9.E8.80.85.E7.9A.84.E5.8F.AF.E9.9D.A0.E6.80.A7.E4.BF.9D.E8.AF.81"></a><h4> <span class="mw-headline"> 消费者的可靠性保证  </span></h4>
<p>消息的消费者是一条接着一条地消费消息，只有在成功消费一条消息后才会接着消费下一条。如果在消费某条消息失败（如异常），则会尝试重试消费这条消息（默认最大5次），超过最大次数后仍然无法消费，则将消息存储在消费者的本地磁盘，由后台线程继续做重试。而主线程继续往后走，消费后续的消息。因此，只有在MessageListener确认成功消费一条消息后，meta的消费者才会继续消费另一条消息。由此来保证消息的可靠消费。
</p><p>消费者的另一个可靠性的关键点是offset的存储，也就是拉取数据的偏移量。我们目前提供了以下几种存储方案
</p>
<ol><li>zookeeper，默认存储在zoopkeeper上，zookeeper通过集群来保证数据的安全性。
</li><li>mysql，可以连接到您使用的mysql数据库，只要建立一张特定的表来存储。完全由数据库来保证数据的可靠性。
</li><li>file，文件存储，将offset信息存储在消费者的本地文件中。
</li></ol>
<p>Offset会定期保存，并且在每次重新负载均衡前都会强制保存一次。
</p><p><br>
</p>
<a name=".E9.A1.BA.E5.BA.8F" id=".E9.A1.BA.E5.BA.8F"></a><h3> <span class="mw-headline"> 顺序  </span></h3>
<p>很多人关心的消息顺序，希望消费者消费消息的顺序跟消息的发送顺序是一致的。比如，我发送消息的顺序是A、B、C，那么消费者消费的顺序也应该是A、B、C。乱序对某些应用可能是无法接受的。
</p><p>Metaq对消息顺序性的保证是有限制的，默认情况下，消息的顺序以谁先达到服务器并写入磁盘，则谁就在先的原则处理。并且，发往同一个分区的消息保证按照写入磁盘的顺序让消费者消费，这是因为消费者针对每个分区都是按照从前到后递增offset的顺序拉取消息。
</p><p>Meta可以保证，在<b>单线程内使用该producer发送的消息按照发送的顺序达到服务器并存储，并按照相同顺序被消费者消费，前提是这些消息发往同一台服务器的同一个分区</b>。为了实现这一点，你还需要实现自己的<b>PartitionSelector</b>用于固定选择分区
</p>
<pre>package com.taobao.Metaq.client.producer;

import java.util.List;


/**
 * 分区选择器
 *
 * @author boyan
 * @Date 2011-4-26
 *
 */
public interface PartitionSelector {

    /**
     * 根据topic、message从partitions列表中选择分区
     *
     * @param topic
     *            topic
     * @param partitions
     *            分区列表
     * @param message
     *            消息
     * @return
     * @throws MetaClientException
     *             此方法抛出的任何异常都应当包装为MetaClientException
     */
    public Partition getPartition(String topic, List&lt;Partition&gt; partitions, Message message) throws MetaClientException;
}

</pre>
<p>选择分区可以按照一定的业务逻辑来选择，如根据业务id来取模。或者如果是传输文件，可以固定选择第n个分区使用。当然，如果传输文件，通常我们会建议你只配置一个分区，那也就无需选择了。
</p><p>消息的顺序发送我们在1.2这个版本提供了OrderedMessageProducer，利用diamond来管理分区信息，并提供故障情况下的本地存储功能。
</p>
<a name=".E6.B6.88.E6.81.AF.E9.87.8D.E5.A4.8D" id=".E6.B6.88.E6.81.AF.E9.87.8D.E5.A4.8D"></a><h3> <span class="mw-headline"> 消息重复  </span></h3>
<p>消息的重复包含两个方面，生产者重复发送消息以及消费者重复消费消息。
</p><p>针对生产者来说，有可能发生这种情况，生产者发送消息，等待服务器应答，这个时候发生网络故障，服务器实际已经将消息写入成功，但是由于网络故障没有返回应答。那么生产者会认为发送失败，则再次发送同一条消息，如果发送成功，则服务器实际存储两条相同的消息。这种由故障引起的重复，meta是无法避免的，因为meta不判断消息的data是否一致，因为它并不理解data的语义，而仅仅是作为载荷来传输。
</p><p>针对消费者来说也有这个问题，消费者成功消费一条消息，但是此时断电，没有及时将前进后的offset存储起来，则下次启动的时候或者其他同个分组的消费者owner到这个分区的时候，会重复消费该条消息。这种情况meta也无法完全避免。
</p><p>Meta对消息重复的保证只能说在正常情况下保证不重复，异常情况无法保证，这些限制是由远程调用的语义引起的，要做到完全不重复的代价很高，meta暂时不会考虑。
</p>
<a name=".E9.9B.86.E7.BE.A4.E5.92.8C.E8.B4.9F.E8.BD.BD.E5.9D.87.E8.A1.A1" id=".E9.9B.86.E7.BE.A4.E5.92.8C.E8.B4.9F.E8.BD.BD.E5.9D.87.E8.A1.A1"></a><h2> <span class="mw-headline"> 集群和负载均衡  </span></h2>
<a name=".E9.9B.86.E7.BE.A4" id=".E9.9B.86.E7.BE.A4"></a><h3> <span class="mw-headline"> 集群  </span></h3>
<p>Meta假定producer、broker和consumer都是分布式的集群系统。
</p><p>Producer可以是一个集群，多台机器上的producer可以往同一个topic发送消息。
</p><p>Meta的服务器broker一般也是一个集群，多台broker组成一个集群提供一些topic服务，生产者按照一定的路由规则往集群里某台broker发送消息，消费者按照一定的路由规则拉取某台broker上的消息。
</p><p>Consumer也可以组织成一个集群来消费同一个topic，发往这个topic的消息按照一定的路由规则发送到consumer集群里的某一台机器。Consumer集群每个consumer必须拥有相同的分组名称。
</p>
<a name=".E8.B4.9F.E8.BD.BD.E5.9D.87.E8.A1.A1" id=".E8.B4.9F.E8.BD.BD.E5.9D.87.E8.A1.A1"></a><h3> <span class="mw-headline"> 负载均衡  </span></h3>
<p>负载均衡和failover分不开，我们将分别讨论下生产者和消费者的负载均衡策略。我们先假定broker是一个集群，这样每个topic必定有多个分区。
</p>
<a name=".E7.94.9F.E4.BA.A7.E8.80.85.E7.9A.84.E8.B4.9F.E8.BD.BD.E5.9D.87.E8.A1.A1.E5.92.8Cfailover" id=".E7.94.9F.E4.BA.A7.E8.80.85.E7.9A.84.E8.B4.9F.E8.BD.BD.E5.9D.87.E8.A1.A1.E5.92.8Cfailover"></a><h4> <span class="mw-headline"> 生产者的负载均衡和failover  </span></h4>
<p>每个broker都可以配置一个topic可以有多少个分区，但是在生产者看来，一个topic在所有broker上的的所有分区组成一个分区列表来使用。
</p><p>在创建producer的时候，客户端会从zookeeper上获取publish的topic对应的broker和分区列表，生产者在发送消息的时候必须选择一台broker上的一个分区来发送消息，默认的策略是一个轮询的路由规则，一张图来表示
</p><p><a href="http://baike.corp.taobao.com/index.php/File:Meta-producer-lb.png" class="image" title="Image:Meta-producer-lb.png"><img alt="Image:Meta-producer-lb.png" src="./userguide_files/Meta-producer-lb.png" width="690" height="384" border="0"></a>
</p><p>生产者在通过zk获取分区列表之后，会按照brokerId和partition的顺序排列组织成一个有序的分区列表，发送的时候按照从头到尾循环往复的方式选择一个分区来发送消息。考虑到我们的broker服务器软硬件配置基本一致，默认的轮询策略已然足够。
</p><p>如果你想实现自己的负载均衡策略，可以实现上文提到过的PartitionSelector接口，并在创建producer的时候传入即可。
</p><p>在broker因为重启或者故障等因素无法服务的时候，producer通过zookeeper会感知到这个变化，将失效的分区从列表中移除做到fail over。因为从故障到感知变化有一个延迟，可能在那一瞬间会有部分的消息发送失败。
</p>
<a name=".E6.B6.88.E8.B4.B9.E8.80.85.E7.9A.84.E8.B4.9F.E8.BD.BD.E5.9D.87.E8.A1.A1" id=".E6.B6.88.E8.B4.B9.E8.80.85.E7.9A.84.E8.B4.9F.E8.BD.BD.E5.9D.87.E8.A1.A1"></a><h4> <span class="mw-headline"> 消费者的负载均衡  </span></h4>
<p>消费者的负载均衡会相对复杂一些。我们这里讨论的是单个分组内的消费者集群的负载均衡，不同分组的负载均衡互不干扰，没有讨论的必要。
</p><p>消费者的负载均衡跟topic的分区数目紧密相关，要考察几个场景。 首先是，单个分组内的消费者数目如果比总的分区数目多的话，则多出来的消费者不参与消费，如图
</p><p><a href="http://baike.corp.taobao.com/index.php/File:Meta-consumer-lb1.png" class="image" title="Image:Meta-consumer-lb1.png"><img alt="Image:Meta-consumer-lb1.png" src="./userguide_files/Meta-consumer-lb1.png" width="712" height="350" border="0"></a>
</p><p>其次，如果分组内的消费者数目比分区数目小，则有部分消费者要额外承担消息的消费任务，具体见示例图如下
</p><p><a href="http://baike.corp.taobao.com/index.php/File:Meta-consumer-lb2.png" class="image" title="Image:Meta-consumer-lb2.png"><img alt="Image:Meta-consumer-lb2.png" src="./userguide_files/Meta-consumer-lb2.png" width="735" height="403" border="0"></a>
</p><p>综上所述，单个分组内的消费者集群的负载均衡策略如下
</p>
<ol><li>每个分区针对同一个group只挂载一个消费者
</li><li>如果同一个group的消费者数目大于分区数目，则多出来的消费者将不参与消费
</li><li>如果同一个group的消费者数目小于分区数目，则有部分消费者需要额外承担消费任务
</li></ol>
<p>Meta的客户端会自动帮处理消费者的负载均衡，它会将消费者列表和分区列表分别排序，然后按照上述规则做合理的挂载。
</p><p>从上述内容来看，合理地设置分区数目至关重要。如果分区数目太小，则有部分消费者可能闲置，如果分区数目太大，则对服务器的性能有影响。
</p><p>在某个消费者故障或者重启等情况下，其他消费者会感知到这一变化（通过 zookeeper watch消费者列表），然后重新进行负载均衡，保证所有的分区都有消费者进行消费。
</p>
<a name=".E6.9C.8D.E5.8A.A1.E5.99.A8.E9.83.A8.E7.BD.B2" id=".E6.9C.8D.E5.8A.A1.E5.99.A8.E9.83.A8.E7.BD.B2"></a><h2> <span class="mw-headline"> 服务器部署  </span></h2>
<a name=".E5.89.8D.E6.8F.90.EF.BC.9A.E5.AE.89.E8.A3.85zookeeper" id=".E5.89.8D.E6.8F.90.EF.BC.9A.E5.AE.89.E8.A3.85zookeeper"></a><h3> <span class="mw-headline"> 前提：安装zookeeper  </span></h3>
<p>首先你需要搭建自己的zookeeper集群，meta利用zookeeper做服务的注册和发现，以及默认情况下offset的存储。
</p><p><br>
</p>
<a name=".E7.AC.AC.E4.BA.8C.E6.AD.A5.EF.BC.9A.E9.85.8D.E7.BD.AEserver.ini" id=".E7.AC.AC.E4.BA.8C.E6.AD.A5.EF.BC.9A.E9.85.8D.E7.BD.AEserver.ini"></a><h3> <span class="mw-headline"> 第二步：配置server.ini  </span></h3>
<p>利用文本编辑器编辑conf/server.ini，这是meta服务器的配置文件，主要关注这几个配置项：
</p>
<ul><li>brokerId 服务器ID，必须是集群内唯一
</li><li>numPartitions 默认每个topic的分区数目
</li><li>dataPath 数据文件的存放路径，默认在user.home/meta下
</li><li>zookeeper配置：
</li></ul>
<pre>;以下为zk配置，可以为空，为空将从diamond获取，不为空则优先使用下列配置
zk.zkConnect=localhost:2181
;zk心跳超时，单位毫秒，默认30秒
zk.zkSessionTimeoutMs=30000
;zk连接超时时间，单位毫秒，默认30秒
zk.zkConnectionTimeoutMs=30000
;zk数据同步时间，单位毫秒，默认5秒
zk.zkSyncTimeMs=5000
</pre>
<p>zookeeper的地址也可以通过diamond管理，如果本地不明确配置zookeeper，则设置diamond的dataId和group即可自动从diamond获取zookeeper配置：
</p>
<pre>;zk在diamond中配置存储的dataId
diamondZKDataId=Metaq.zkConfig
;zk在diamond中配置存储的group
diamondZKGroup=DEFAULT_GROUP
</pre>
<p>一份默认的文件如下：
</p>
<pre>;
;   Metaq服务器的参数配置文件 2.0 版本
;   有疑问请联系我 boyan@taobao.com（伯岩）
;

;系统属性
[system]
;必须，服务器唯一标志
brokerId=0

;服务器hostname，可以为空，默认将取本机IP
hostName=

;默认每个topic的分区数目，默认为1
numPartitions=1

;服务器端口，必须
serverPort=8123

;数据文件路径，默认在user.home/meta下
dataPath=

;最大允许的未flush消息数，超过此值将强制force到磁盘，默认1000
unflushThreshold=1000

;最大允许的未flush间隔时间，毫秒，默认10秒
unflushInterval=10000

;单个文件的最大大小,实际会超过此值，默认1G
maxSegmentSize=1073741824

;传输给客户端每次最大的缓冲区大小，默认1M
maxTransferSize=1048576

;处理get请求的线程数,默认cpus*10
getProcessThreadCount=80

;处理put请求线程数，默认cpus*10
putProcessThreadCount=80

;数据删除策略，默认超过7天即删除
deletePolicy=delete,168

;事务相关配置

;最大保存事务checkpoint数目，默认为3
maxCheckpoints=3
;事务checkpoint时间间隔，单位毫秒，默认1小时
checkpointInterval=3600000
;最大事务超时事件数，用于监控事务超时
maxTxTimeoutTimerCapacity=30000
;最大事务超时时间，单位秒
maxTxTimeoutInSeconds=60
;事务日志的刷盘设置，0表示让操作系统决定，1表示每次commit都刷盘，2表示每隔1秒刷盘一次
flushTxLogAtCommit=1

;zk配置
[zookeeper]
;以下为zk配置，可以为空，为空将从diamond获取，不为空则优先使用下列配置
;zk的服务器列表
;zk.zkConnect=localhost:2181
;zk心跳超时，单位毫秒，默认30秒
;zk.zkSessionTimeoutMs=30000
;zk连接超时时间，单位毫秒，默认30秒
;zk.zkConnectionTimeoutMs=30000
;zk数据同步时间，单位毫秒，默认5秒
;zk.zkSyncTimeMs=5000

;zk在diamond中配置存储的dataId
diamondZKDataId=Metaq.zkConfig
;zk在diamond中配置存储的group
diamondZKGroup=DEFAULT_GROUP

;HA中的slave配置
[slave]
;slave编号,大于等于0表示作为slave启动,同一个master下的slave编号应该设不同值.
;没配置或小于0时作为master启动
slaveId=-1

;作为slave启动时向master订阅消息的group,如果没配置则默认为meta-slave-group
;master也会用它来识别slave
slaveGroup=meta-slave-group

;slave数据同步的最大延时,单位毫秒
slaveMaxDelayInMills=500

;topic列表
[topic=boyan-test]
;是否启用统计
stat=true
;这个topic指定分区数目，如果没有设置，则使用系统设置
numPartitions=1
;topic的删除策略，默认使用系统策略
deletePolicy=
unflushInterval=
unflushThreshold=

</pre>
<a name=".E7.AC.AC.E4.B8.89.E6.AD.A5.EF.BC.9A.E5.90.AF.E5.8A.A8.E6.9C.8D.E5.8A.A1.E5.99.A8" id=".E7.AC.AC.E4.B8.89.E6.AD.A5.EF.BC.9A.E5.90.AF.E5.8A.A8.E6.9C.8D.E5.8A.A1.E5.99.A8"></a><h3> <span class="mw-headline"> 第三步：启动服务器  </span></h3>
<pre>   cd bin
   sh meta-server-start.sh -f ../conf/server.ini
</pre>
<p>其中-f选项用于指定配置文件所在完整路径。 启动meta服务器后，你可以telnet到8123端口测试
</p>
<pre>    telnet localhost 8123
    stats
</pre>
<p>8123是meta服务器的默认端口，我们telnet上去并敲一个stats命令看看。敲quit命令可以退出telnet交互。
</p><p>启动后，可以查看metaServer.log。
</p>
<a name=".E5.85.B3.E9.97.AD.E6.9C.8D.E5.8A.A1.E5.99.A8" id=".E5.85.B3.E9.97.AD.E6.9C.8D.E5.8A.A1.E5.99.A8"></a><h3> <span class="mw-headline"> 关闭服务器  </span></h3>
<p>关闭服务器通过meta-server-stop.sh脚本即可关闭
</p>
<pre>    sh meta-server-stop.sh
</pre>
<a name=".E6.9C.8D.E5.8A.A1.E5.99.A8.E7.9A.84.E5.BF.AB.E9.80.9F.E5.90.AF.E5.8A.A8" id=".E6.9C.8D.E5.8A.A1.E5.99.A8.E7.9A.84.E5.BF.AB.E9.80.9F.E5.90.AF.E5.8A.A8"></a><h3> <span class="mw-headline"> 服务器的快速启动  </span></h3>
<p>Meta服务器在启动的时候会一个一个地校验所有文件，如果文件数目较多，那么这个启动过程会非常慢，如果想加快启动过程，可以使用fast_boot选项，在meta-run-class.sh脚本里添加环境变量
</p>
<pre>META_OPTS="-Xmx512m -server -Dcom.sun.management.jmxremote -Dlog4j.configuration=$base_dir/bin/log4j.properties -Dmeta.fast_boot=true"
</pre>
<p>将meta.fast_boot设置为true即可跳过校验环节快速启动。
</p>
<a name=".E6.B6.88.E6.81.AF.E7.9A.84.E5.88.A0.E9.99.A4.E7.AD.96.E7.95.A5" id=".E6.B6.88.E6.81.AF.E7.9A.84.E5.88.A0.E9.99.A4.E7.AD.96.E7.95.A5"></a><h3> <span class="mw-headline"> 消息的删除策略  </span></h3>
<p>目前服务端支持两种删除策略：
</p>
<ul><li>定期删除，保存消息一定时间，超过指定时间就无条件删除。例如
</li></ul>
<pre>deletePolicy=delete,72
</pre>
<p>的配置就是指使用删除策略，保存至少72个小时，超过即删除。
</p>
<ul><li>定期压缩归档，保存消息一定时间，超过指定时间就将消息压缩归档，例如
</li></ul>
<pre>deletePolicy=archive,72
</pre>
<p>的配置就是指使用归档策略，保存至少72个小时，超过即归档。归档后的文件名前缀不变（也就是start offset)，后缀变为arc。归档策略还可以指定是否压缩：
</p>
<pre>deletePolicy=archive,72,true
</pre>
<p>第三个参数true指定归档策略使用压缩，meta使用zip压缩算法，压缩后的文件后缀即为zip，前缀不变。
</p>
<a name=".E6.9C.80.E4.BD.B3.E5.AE.9E.E8.B7.B5" id=".E6.9C.80.E4.BD.B3.E5.AE.9E.E8.B7.B5"></a><h2> <span class="mw-headline"> 最佳实践  </span></h2>
<a name=".E5.AE.A2.E6.88.B7.E7.AB.AF.E6.9C.80.E4.BD.B3.E5.AE.9E.E8.B7.B5" id=".E5.AE.A2.E6.88.B7.E7.AB.AF.E6.9C.80.E4.BD.B3.E5.AE.9E.E8.B7.B5"></a><h3> <span class="mw-headline"> 客户端最佳实践  </span></h3>
<ul><li>复用MessageSessionFactory，最好作为全局单例使用
</li></ul>
<a name=".E7.94.9F.E4.BA.A7.E8.80.85.E6.9C.80.E4.BD.B3.E5.AE.9E.E8.B7.B5" id=".E7.94.9F.E4.BA.A7.E8.80.85.E6.9C.80.E4.BD.B3.E5.AE.9E.E8.B7.B5"></a><h3> <span class="mw-headline"> 生产者最佳实践  </span></h3>
<ul><li>尽量复用MessageProducer，可以单个MessageProducer发送多种topic，或者多个MessageProducer每个发送一种topic，前提是不要重复创建。
</li><li>消息data的序列化方式建议不要使用特定于语言的序列化方式（如java序列化），可考虑自定义协议、json、protobufs、hessian都序列化协议，以便跨语言消费。
</li><li>实现发送顺序所需要的ParitionSelector，我们会推荐使用业务id，如交易订单id来取模分区列表选择固定分区发送。
</li><li>单条消息大小最好限制在百k以下。
</li><li>如无顺序等特殊要求，不要实现自己的PartitionSelector,默认的轮询策略足够。
</li></ul>
<a name=".E6.B6.88.E8.B4.B9.E8.80.85.E7.9A.84.E6.9C.80.E4.BD.B3.E5.AE.9E.E8.B7.B5" id=".E6.B6.88.E8.B4.B9.E8.80.85.E7.9A.84.E6.9C.80.E4.BD.B3.E5.AE.9E.E8.B7.B5"></a><h3> <span class="mw-headline"> 消费者的最佳实践  </span></h3>
<ul><li>尽量复用MessageConsumer，可以单个MessageConsumer订阅多种topic，或者多个MessageConsumer每个订阅一种topic，前提是不要重复创建。
</li><li>单次拉取的数据不宜过大，对消息实时性要求较高的应用，应将单次拉取的数据缩小，但至少大于单条消息的大小。如对吞吐量要求较高，可将该值设大。
</li><li>如消费过程非常轻量级(比如只是打印)，可不设置MessageListener线程池，减少资源耗费。
</li><li>如消息发送量巨大，消费能力不高，可适当提高拉取消息线程数fetchRunnerCount和MessageListener的线程池大小。
</li><li>尽量在消息消费过程中捕捉所有异常，减少消息在本地的堆积和恢复，前提是不要遗漏消息。如确实无法处理，请主动抛出异常以便重试。
</li></ul>
<p><br>
</p>
<a name=".E5.8E.9F.E7.90.86.E5.92.8C.E5.AE.9E.E7.8E.B0" id=".E5.8E.9F.E7.90.86.E5.92.8C.E5.AE.9E.E7.8E.B0"></a><h2> <span class="mw-headline"> 原理和实现  </span></h2>
<a name=".E8.AE.BE.E8.AE.A1.E5.8E.9F.E7.90.86" id=".E8.AE.BE.E8.AE.A1.E5.8E.9F.E7.90.86"></a><h3> <span class="mw-headline"> 设计原理  </span></h3>
<p>整体的设计思路与kafka是完全一致的，kafka的设计文档可以作为meta的参考文档
</p><p><a href="http://sna-projects.com/kafka/design.php" class="external free" title="http://sna-projects.com/kafka/design.php" target="_blank" rel="nofollow">http://sna-projects.com/kafka/design.php</a>
</p><p>实现上大体介绍下。
</p>
<a name=".E7.BD.91.E7.BB.9C.E9.80.9A.E8.AE.AF.E5.92.8C.E5.8D.8F.E8.AE.AE" id=".E7.BD.91.E7.BB.9C.E9.80.9A.E8.AE.AF.E5.92.8C.E5.8D.8F.E8.AE.AE"></a><h3> <span class="mw-headline"> 网络通讯和协议  </span></h3>
<p>采用notify-remoting做为通讯模块，实现meta的协议。Meta的协议是基于文本行的协议，类似memcached的文本协议。通用的协议格式如下
</p>
<pre>  command params opaque\r\n
  body
</pre>
<p>其中command为协议命令，params为参数列表，而opaque为协议的序列号，用于请求和应答的映射。客户端发送协议的时候需要自增此序列号，而服务端将拷贝来自客户端的序列号并作为应答的序列号返回，客户端可根据应答的序列号将应答和请求对应起来。body为协议体，可选，在协议头里需要有字段指名body长度。
</p><p>协议命令包括
</p>
<table border="1" cellspacing="0" cellpadding="5">

<tbody><tr>
<th> 命令
</th><th> 参数
</th><th> 说明
</th><th> 示例
</th></tr>
<tr>
<td> put
</td><td> topic partition value-length flag [transactionKey]
</td><td> 发送消息协议,topic为发送的消息主题，partition为发送的目的分区，value-length为发送的消息体长度,flag为消息标识位,transactionKey为事务标识符，可选。
</td><td> put meta-test 0 5 0 1\r\nhello
</td></tr>
<tr>
<td> get
</td><td> topic group partition offset maxSize
</td><td> 消费者拉取消息协议，topic为拉取的消息主题，group为消费者分组名称，partition为拉取的目的分区，offset为拉取的起始偏移量，maxSize为本次拉取的最大数据量大小。
</td><td> get meta-test example 0 1024 512 1\r\n
</td></tr>
<tr>
<td> data
</td><td> total-length
</td><td> get请求返回的应答，total-length返回的数据长度。
</td><td> data 5 1\r\nhello
</td></tr>
<tr>
<td> result
</td><td> code length
</td><td> 通用应答协议，如返回请求结果。code为应答状态码，采用与HTTP应答状态码一样的语义。length为协议体长度
</td><td> result 200 0 1\r\n
</td></tr>
<tr>
<td> offset
</td><td> topic group partition offset
</td><td> 查询离某个offset的最近有效的offset,topic为查询的消息主题，group为消费者分组名称，partition为查询的分区,offset为查询的offset
</td><td> offset meta-test example 0 1024 1\r\n
</td></tr>
<tr>
<td> stats
</td><td> item(可选)
</td><td> 查询服务器的统计情况，item为查询的项目名称，如realtime(实时统计),具体的某个topic等，可以为空。
</td><td> stats 1\r\n
</td></tr></tbody></table>
<p>整个协议采用文本方式，非常适合其他语言实现客户端。
</p>
<a name=".E6.B6.88.E6.81.AF.E7.9A.84.E5.AD.98.E5.82.A8.E7.BB.93.E6.9E.84" id=".E6.B6.88.E6.81.AF.E7.9A.84.E5.AD.98.E5.82.A8.E7.BB.93.E6.9E.84"></a><h3> <span class="mw-headline"> 消息的存储结构  </span></h3>
<p>消息在服务器的是按照顺序连续append在一起的，具体的单个消息的存储结构如下：
</p>
<ul><li>message length(4 bytes),包括消息属性和payload data
</li><li>checksum(4 bytes)
</li><li>message id(8 bytes)
</li><li>message flag(4 bytes)
</li><li>attribute length(4 bytes) + attribute，可选
</li><li>payload
</li></ul>
<p>其中checksum采用CRC32算法计算，计算的内容包括消息属性长度+消息属性+data，消息属性如果不存在则不包括在内。消费者在接收到消息后会检查checksum是否正确。
</p><p>同一个topic下有不同分区，每个分区下面会划分为多个文件，只有一个当前文件在写，其他文件只读。当写满一个文件（写满的意思是达到设定值）则切换文件，新建一个当前文件用来写，老的当前文件切换为只读。文件的命名以起始偏移量来命名。看一个例子，假设meta-test这个topic下的0-0分区可能有以下这些文件：
</p>
<ul><li>00000000000000000000000000000000.meta
</li><li>00000000000000000000000000001024.meta
</li><li>00000000000000000000000000002048.meta
</li><li>……
</li></ul>
<p>其中00000000000000000000000000000000.meta表示最开始的文件，起始偏移量为0。第二个文件00000000000000000000000000001024.meta的起始偏移量为1024，同时表示它的前一个文件的大小为1024-0=1024。同样，第三个文件00000000000000000000000000002048.meta的起始偏移量为2048，表明00000000000000000000000000001024.meta的大小为2048-1024=1024。
</p><p>以起始偏移量命名并排序这些文件，那么当消费者要抓取某个起始偏移量开始位置的数据变的相当简单，只要根据传上来的offset二分查找文件列表，定位到具体文件，然后将绝对offset减去文件的起始节点转化为相对offset，即可开始传输数据。例如，同样以上面的例子为例，假设消费者想抓取从1536开始的数据1M，则根据1536二分查找，定位到00000000000000000000000000001024.meta这个文件（1536在1024和2048之间），1536-1024=512，也就是实际传输的起始偏移量是在00000000000000000000000000001024.meta文件的512位置。因为1024.meta的大小才1K，比1M小多了，实际传输的数据只有2048-1536=512字节。
</p><p>这些文件在meta里命名为Segment，每个Segment对应一个FileMessageSet。文件组织成SegmentList，整体成为一个MessageStore，一个topic下的一个分区对应一个MessageStore。一张图如下
</p><p><a href="http://baike.corp.taobao.com/index.php/File:Meta-store.png" class="image" title="Image:Meta-store.png"><img alt="Image:Meta-store.png" src="./userguide_files/Meta-store.png" width="625" height="467" border="0"></a>
</p>
<a name=".E6.B6.88.E6.81.AF.E7.9A.84.E6.81.A2.E5.A4.8D.E5.92.8C.E9.87.8D.E8.AF.95" id=".E6.B6.88.E6.81.AF.E7.9A.84.E6.81.A2.E5.A4.8D.E5.92.8C.E9.87.8D.E8.AF.95"></a><h3> <span class="mw-headline"> 消息的恢复和重试  </span></h3>
<p>当消费者无法正常消费某条消息的适合，meta客户端会将消息存储在消费者本地磁盘，并在后台线程重试。存储是采用notify-store4j，notify-store4j的存储是按照插入顺序存储的的，因此可以保证按照顺序做消息的recover。 notify-store4j的具体实现请看notify源码。
</p>
<a name="HA.E5.BC.82.E6.AD.A5.E5.A4.8D.E5.88.B6.E6.96.B9.E6.A1.88" id="HA.E5.BC.82.E6.AD.A5.E5.A4.8D.E5.88.B6.E6.96.B9.E6.A1.88"></a><h3> <span class="mw-headline"> HA异步复制方案  </span></h3>
<p>Meta的HA(High Availability)提供了在某些Broker出现故障时继续工作而不影响消息服务的可用性；跟HA关系紧密的就是Failover，当故障Server恢复时能重新加入Cluster处理请求，这个过程对消息服务的使用者是透明的。Meta基于Master/Slave实现HA，Slave以作为Master的订阅者（consumer）来跟踪消息记录，当消息发送到Master时候，Slave会定时的获取此消息记录，并存储在自己的Store实现上；当Master出现故障无法继续使用了，消息还会在Slave上Backup的记录。这种方式不影响原有的消息的记录，一旦master记录成功，就返回成功，不用等待在slave上是否记录；正因如此，slave和master还有稍微一点的时间差异，在Master出故障那一瞬间，或许有最新产生的消息，就无法同步到slave；另外Slave可以作为Consumer的服务提供者，意思就是如果要写入必须通过Master，消费时候可以从Slave上直接获取。如下图。
</p><p><a href="http://baike.corp.taobao.com/index.php/File:HA.GIF" class="image" title="Image:HA.GIF"><img alt="Image:HA.GIF" src="./userguide_files/HA.GIF" width="891" height="607" border="0"></a><br>
</p><p><br>
</p><p>Failover机制采用client端方式，Master和Slave都需要注册到ZK上，一旦Master无法使用，客户端可使用与之对应的Slave；当Master的故障恢复时候，这时候有两种方式处理：
</p>
<ul><li>原来的master变成Slave，Slave变成Master；恢复故障的broker作为slave去之前的Slave同步消息。优点简单，但是需要slave和Master有一样的配置和处理能力，这样就能取代Master的位置。（目前Meta采用此方式）
</li><li>需要自动把请求重新转移回恢复的Master。实现复杂，需要再次把最新的消息从Slave复制会Master，在复制期间还要考虑处理最新的消息服务（Producer可以暂存消息在本地，等复制成功后再和Broker交互）。
</li></ul>
<a name="FAQ" id="FAQ"></a><h2> <span class="mw-headline"> FAQ  </span></h2>
<a name=".E9.87.87.E7.94.A8pull.E6.A8.A1.E5.9E.8B.EF.BC.8C.E6.B6.88.E6.81.AF.E7.9A.84.E5.AE.9E.E6.97.B6.E6.80.A7.E6.9C.89.E4.BF.9D.E8.AF.81.E5.90.97.EF.BC.9F" id=".E9.87.87.E7.94.A8pull.E6.A8.A1.E5.9E.8B.EF.BC.8C.E6.B6.88.E6.81.AF.E7.9A.84.E5.AE.9E.E6.97.B6.E6.80.A7.E6.9C.89.E4.BF.9D.E8.AF.81.E5.90.97.EF.BC.9F"></a><h3> <span class="mw-headline"> 采用pull模型，消息的实时性有保证吗？  </span></h3>
<p>Metaq在消费端采用pull的模型，consumer主动去broker拉取数据，而不是类似notify那样由broker主动push数据给消费者。可能很多人担心采用pull模型后，会不会消息的实时性降低了，从发送到消费的整个时间周期拉长了。
</p><p>实际上，meta中消息的实时性受很多因素影响，不能简单地说实时性一定会降低，主要影响因素如下
</p>
<ol><li>broker上配置的批量force消息的阈值，默认是1000条force一次。这个值越大，则实时性越低。
</li><li>消费者每次抓取的数据大小，这个值越大，则实时性越低，但是吞吐量越高。
</li><li>Topic的分区数目对实时性也有较大影响，分区数目越多，则磁盘压力越大，导致消息投递的实时性降低。
</li><li>消费者重试抓取的时间间隔，越长则延迟越严重。
</li><li>消费者抓取数据的线程数
</li></ol>
<p>可见，消息实时性在meta里受到很多因素的影响，meta可以让用户自己决定如何在响应性和吞吐量之间做平衡，通过配置来合理设置参数，达到应用方需要的实时性，实际测试，消息消费的延迟可以在几毫秒到几秒之间。
</p>
<a name="Metaq.E6.80.8E.E4.B9.88.E5.81.9A.E5.88.B0.E7.8E.AF.E5.A2.83.E9.9A.94.E7.A6.BB.EF.BC.9F" id="Metaq.E6.80.8E.E4.B9.88.E5.81.9A.E5.88.B0.E7.8E.AF.E5.A2.83.E9.9A.94.E7.A6.BB.EF.BC.9F"></a><h3> <span class="mw-headline"> Metaq怎么做到环境隔离？  </span></h3>
<p>有的朋友可能想搭建自己的meta开发和测试环境，不想使用日常的。这也完全可以，meta环境隔离的主要问题是zookeeper环境的隔离，你可以搭建一台自己的zookeeper，然后配置下meta的broker使用你自己的zookeeper，就可以完全跟日常环境隔离开。这是在服务端server.properties中配置
</p>
<pre>#以下为zk配置，可以为空，为空将从diamond获取，不为空则优先使用下列配置
#zk的服务器列表
zk.zkConnect=localhost:2181
#zk心跳超时，单位毫秒，默认30秒
zk.zkSessionTimeoutMs=30000
#zk连接超时时间，单位毫秒，默认30秒
zk.zkConnectionTimeoutMs=30000
#zk数据同步时间，单位毫秒，默认5秒
zk.zkSyncTimeMs=5000
</pre>
<p>如果你不想写死zk配置在服务端，也可以在diamond里配置上述的这些参数，然后在broker的server.properties配置下使用的diamond的dataId和group，meta会使用diamond client获取zk配置
</p>
<pre>#zk在diamond中配置存储的dataId
diamondZKDataId=Metaq.zkConfig
#zk在diamond中配置存储的group
diamondZKGroup=DEFAULT_GROUP
</pre>
<a name=".E5.B8.B8.E8.A7.81.E9.94.99.E8.AF.AF.E5.8F.8A.E5.A4.84.E7.90.86.E5.8A.9E.E6.B3.95" id=".E5.B8.B8.E8.A7.81.E9.94.99.E8.AF.AF.E5.8F.8A.E5.A4.84.E7.90.86.E5.8A.9E.E6.B3.95"></a><h3> <span class="mw-headline"> 常见错误及处理办法  </span></h3>
<p>a.客户端发送消息时，报错： There is no aviable partition for topic xiafei-test-1,maybe you don't publish it at first?
</p><p>答：
</p>
<ol><li>客户端发消息前有没有调用过publish？ 如果没有则在发送消息前调用publish方法。
</li><li>server端是否有注册过对应的topic，如果没有注册过topic先在server端注册该topic。 在conf目录下topic.ini（老版本在server.ini）文件中添加topic的配置,并重启server（bin目录start.sh）或者重载（tool包bin目录下reloadconfig.sh）
</li></ol>
<a name=".E6.B6.88.E6.81.AF.E8.BF.87.E6.BB.A4" id=".E6.B6.88.E6.81.AF.E8.BF.87.E6.BB.A4"></a><h2> <span class="mw-headline"> 消息过滤  </span></h2>
<p>metaq2.1.3版本开始支持消息过滤的功能。消息的生产者可以设置消息类型，消费者可以针对消息类型选择性的消费。
</p>
<a name=".E5.AE.9E.E7.8E.B0.E5.8E.9F.E7.90.86" id=".E5.AE.9E.E7.8E.B0.E5.8E.9F.E7.90.86"></a><h3> <span class="mw-headline"> 实现原理  </span></h3>
<p><b>消息生产者：</b>每条消息可以设置一个消息类型，客户端中的消息类型借用attribute字段。
</p><p><b>消息消费者：</b>客户端向服务器汇报自己需要的消息类型列表。
</p><p><b>metaq 服务器：</b>客户端使用FetchCommand拉取消息的时候，服务器根据客户端订阅的消息类型过滤消息，过滤服务端的消息，把过滤后的消息发送给客户端，保证客户端只接收到订阅的消息类型。
</p>
<a name=".E7.A4.BA.E4.BE.8B.E4.BB.A3.E7.A0.81" id=".E7.A4.BA.E4.BE.8B.E4.BB.A3.E7.A0.81"></a><h3> <span class="mw-headline"> 示例代码  </span></h3>
<p>生产者示例：
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="java source-java"><pre class="de1"><span class="co1">// New session factory</span>
        <span class="kw1">final</span> MessageSessionFactory sessionFactory <span class="sy0">=</span> <span class="kw1">new</span> MetaMessageSessionFactory<span class="br0">(</span><span class="kw1">new</span> MetaClientConfig<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="co1">// create producer</span>
        <span class="kw1">final</span> MessageProducer producer <span class="sy0">=</span> sessionFactory.<span class="me1">createProducer</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="co1">// publish topic</span>
        <span class="kw1">final</span> <span class="kw3">String</span> topic <span class="sy0">=</span> <span class="st0">"meta-test-20"</span><span class="sy0">;</span>
        producer.<span class="me1">publish</span><span class="br0">(</span>topic<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
        <span class="kw1">final</span> <span class="kw3">BufferedReader</span> reader <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw3">BufferedReader</span><span class="br0">(</span><span class="kw1">new</span> <span class="kw3">InputStreamReader</span><span class="br0">(</span><span class="kw3">System</span>.<span class="me1">in</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="kw3">String</span> line <span class="sy0">=</span> <span class="kw2">null</span><span class="sy0">;</span>
        <span class="kw1">while</span> <span class="br0">(</span><span class="kw2">true</span><span class="br0">)</span> <span class="br0">{</span>
        	<span class="kw3">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"type message content:"</span><span class="br0">)</span><span class="sy0">;</span>
        	line <span class="sy0">=</span> reader.<span class="me1">readLine</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        	Message message <span class="sy0">=</span> <span class="kw1">new</span> Message<span class="br0">(</span>topic, line.<span class="me1">getBytes</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
        	<span class="kw3">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"type message filter:"</span><span class="br0">)</span><span class="sy0">;</span>
        	line <span class="sy0">=</span> reader.<span class="me1">readLine</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        	message.<span class="me1">setAttribute</span><span class="br0">(</span>line<span class="br0">)</span><span class="sy0">;</span><span class="co1">//通过attribute字段设置消息类型</span>
            <span class="co1">// send message</span>
            <span class="kw1">final</span> SendResult sendResult <span class="sy0">=</span> producer.<span class="me1">sendMessage</span><span class="br0">(</span>message<span class="br0">)</span><span class="sy0">;</span>
            <span class="co1">// check result</span>
            <span class="kw1">if</span> <span class="br0">(</span><span class="sy0">!</span>sendResult.<span class="me1">isSuccess</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
                <span class="kw3">System</span>.<span class="me1">err</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"Send message failed,error message:"</span> <span class="sy0">+</span> sendResult.<span class="me1">getErrorMessage</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
            <span class="br0">}</span>
            <span class="kw1">else</span> <span class="br0">{</span>
                <span class="kw3">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"Send message successfully,sent to "</span> <span class="sy0">+</span> sendResult.<span class="me1">getPartition</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
            <span class="br0">}</span>
        <span class="br0">}</span></pre></div></div>
<p>消费者示例：
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="java source-java"><pre class="de1"><span class="co1">// New session factory</span>
        <span class="kw1">final</span> MessageSessionFactory sessionFactory <span class="sy0">=</span> <span class="kw1">new</span> MetaMessageSessionFactory<span class="br0">(</span>buildMetaClientConfig<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="co1">// subscribed topic</span>
        <span class="kw1">final</span> <span class="kw3">String</span> topic <span class="sy0">=</span> <span class="st0">"meta-test-20"</span><span class="sy0">;</span>
        <span class="co1">// consumer group</span>
        <span class="kw1">final</span> <span class="kw3">String</span> group <span class="sy0">=</span> <span class="st0">"meta-vintage-x-4"</span><span class="sy0">;</span>
        <span class="co1">// create consumer</span>
        <span class="kw1">final</span> MessageConsumer consumer <span class="sy0">=</span> sessionFactory.<span class="me1">createConsumer</span><span class="br0">(</span><span class="kw1">new</span> ConsumerConfig<span class="br0">(</span>group<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
        <span class="kw3">String</span><span class="br0">[</span><span class="br0">]</span> types <span class="sy0">=</span> <span class="br0">{</span><span class="st0">"type1"</span>,<span class="st0">"type2"</span><span class="br0">}</span><span class="sy0">;</span><span class="co1">//需要接受的消息类型列表</span>
        <span class="co1">// subscribe topic</span>
        consumer.<span class="me1">subscribe</span><span class="br0">(</span>topic, <span class="nu0">1024</span> <span class="sy0">*</span> <span class="nu0">1024</span>, <span class="kw1">new</span> MessageListener<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
&nbsp;
            <span class="kw1">public</span> <span class="kw4">void</span> recieveMessages<span class="br0">(</span><span class="kw1">final</span> Message message<span class="br0">)</span> <span class="br0">{</span>
                <span class="kw3">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"newId:"</span> <span class="sy0">+</span> message.<span class="me1">getMsgNewId</span><span class="br0">(</span><span class="br0">)</span> <span class="sy0">+</span> <span class="st0">"<span class="es0">\t</span> attribute is:"</span> <span class="sy0">+</span> message.<span class="me1">getAttribute</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
            <span class="br0">}</span>
&nbsp;
            <span class="kw1">public</span> Executor getExecutor<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
                <span class="kw1">return</span> <span class="kw2">null</span><span class="sy0">;</span>
            <span class="br0">}</span>
        <span class="br0">}</span>, types<span class="br0">)</span><span class="sy0">;</span>
        <span class="co1">// complete subscribe</span>
        consumer.<span class="me1">completeSubscribe</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span></pre></div></div>
<a name=".E6.B3.A8.E6.84.8F.E4.BA.8B.E9.A1.B9" id=".E6.B3.A8.E6.84.8F.E4.BA.8B.E9.A1.B9"></a><h3> <span class="mw-headline"> 注意事项  </span></h3>
<p>1.attribute字段，可能原先被使用用作分区选择器的key，attribute字段是会被存储在服务端的数据，如果只是用过分区选择器用，推荐使用message.setArg(Object arg)。这个字段不会被发送到服务器存储
</p><p>2.集群中订阅信息的版本是客户端启动的时间，以时间最大的为准。如果应用修改了过滤条件重启，即使只重启了一台，服务端会强制刷新同一分组，同一topic所有机器的订阅关系。
</p><p>3.消息类型只允许英文字符，数字，下划线。其他的特殊字符和中文不支持，订阅的时候会抛出异常。
</p>
<a name=".E9.99.84.E5.BD.95.E4.BF.A1.E6.81.AF" id=".E9.99.84.E5.BD.95.E4.BF.A1.E6.81.AF"></a><h2> <span class="mw-headline"> 附录信息  </span></h2>
<p>javadoc链接 <a href="http://10.232.102.184:3000/apidocs/index.html" class="external free" title="http://10.232.102.184:3000/apidocs/index.html" target="_blank" rel="nofollow">http://10.232.102.184:3000/apidocs/index.html</a>
</p><p>项目SCM管理 <a href="http://svn.app.taobao.net/repos/Metaq/trunk/Metaq" class="external free" title="http://svn.app.taobao.net/repos/Metaq/trunk/Metaq" target="_blank" rel="nofollow">http://svn.app.taobao.net/repos/Metaq/trunk/Metaq</a>
</p><p>http的支持&nbsp;<a href="http://baike.corp.taobao.com/index.php/User_talk:Kongming.lrq" class="external free" title="http://baike.corp.taobao.com/index.php/User_talk:Kongming.lrq" target="_blank" rel="nofollow">http://baike.corp.taobao.com/index.php/User_talk:Kongming.lrq</a>
</p>
<!--
NewPP limit report
Preprocessor node count: 281/1000000
Post-expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key wiki1-tb_baike:pcache:idhash:8939-0!1!0!!zh-hans!2!edit=0 and timestamp 20130105030917 -->
<div class="printfooter">
取自"<a href="./userguide_files/userguide.htm">http://baike.corp.taobao.com/index.php/Metaq-User-Guide</a>"</div>
		<div class="mw_clear"></div>
					</div><!-- mw_contentholder -->
	</div><!-- mw_content -->
	<!-- footer -->
	<script type="text/javascript" src="./userguide_files/tongji.js"></script><img src="./userguide_files/tongji.do" border="0" width="1" height="1"><noscript>&lt;a href="http://www.linezing.com"&gt;&lt;img src="http://img.tongji.linezing.com/1296239/tongji.gif"/&gt;&lt;/a&gt;</noscript>
                <div id="footer">
		                                <div id="f-poweredbyico"><div class="mw_poweredby">Powered by MediaWiki 1.14.0</div></div>
		                      <ul id="f-list">
		                                      <li id="lastmod"> 这页的最后修订在 2012年12月5日 (星期三) 14:29。</li>
		                                      <li id="viewcount">本页面已经被浏览4,422次。</li>
		                                      <li id="privacy"><a href="http://baike.corp.taobao.com/index.php/%E6%B7%98%E5%AE%9D%E7%99%BE%E7%A7%91:%E9%9A%90%E7%A7%81%E6%94%BF%E7%AD%96" title="淘宝百科:隐私政策">隐私政策</a></li>
		                                      <li id="about"><a href="http://baike.corp.taobao.com/index.php/%E6%B7%98%E5%AE%9D%E7%99%BE%E7%A7%91:%E5%85%B3%E4%BA%8E" title="淘宝百科:关于">关于淘宝百科</a></li>
		                                      <li id="disclaimer"><a href="http://baike.corp.taobao.com/index.php/%E6%B7%98%E5%AE%9D%E7%99%BE%E7%A7%91:%E5%85%8D%E8%B4%A3%E5%A3%B0%E6%98%8E" title="淘宝百科:免责声明">免责声明</a></li>
		                        </ul>
		                </div>
</div>
<script type="text/javascript">
rightHeight = document.getElementById("mw_content").scrollHeight;
if (rightHeight < 1000) {
	document.getElementById("mw_content").style.height = '1000px';
}
</script>
	<div id="mw_portlets">

	<!-- portlets -->
			<div class="generated-sidebar portlet" id="p-navigation">
		<h5>导航</h5>
		<div class="pBody">
			<ul>
				<li id="n-mainpage-description"><a href="http://baike.corp.taobao.com/index.php/%E9%A6%96%E9%A1%B5">首页</a></li>
				<li id="n-.E4.BA.A7.E5.93.81"><a href="http://baike.corp.taobao.com/index.php/Products">产品</a></li>
				<li id="n-portal"><a href="http://baike.corp.taobao.com/index.php/%E6%B7%98%E5%AE%9D%E7%99%BE%E7%A7%91:%E7%A4%BE%E5%8C%BA" title="关于本计划, 您可以做什么, 应该如何做">社区</a></li>
				<li id="n-currentevents"><a href="http://baike.corp.taobao.com/index.php/%E6%B7%98%E5%AE%9D%E7%99%BE%E7%A7%91:%E5%BD%93%E5%89%8D%E4%BA%8B%E4%BB%B6" title="提供当前事件的背景资料">当前事件</a></li>
				<li id="n-recentchanges"><a href="http://baike.corp.taobao.com/index.php/Special:%E6%9C%80%E8%BF%91%E6%9B%B4%E6%94%B9" title="列出该网站的最近修改 [r]" accesskey="r">最近更改</a></li>
				<li id="n-randompage"><a href="http://baike.corp.taobao.com/index.php/Special:%E9%9A%8F%E6%9C%BA%E9%A1%B5%E9%9D%A2" title="随机载入一个页面 [x]" accesskey="x">随机页面</a></li>
				<li id="n-help"><a href="http://baike.corp.taobao.com/index.php/Help:%E7%9B%AE%E5%BD%95" title="寻求帮助">帮助</a></li>
			</ul>
		</div><!-- pBody -->
	</div><!-- portlet -->
	<!-- search -->
	<div id="p-search" class="portlet" style="padding:0px 0px 15px 0px">
		<div id="searchBody" class="pBody" style="text-align:left;padding-left:0.5em">

			<form action="http://baike.corp.taobao.com/index.php/Special:%E6%90%9C%E7%B4%A2" id="searchform">
			<input id="searchInput" name="search" style="border:#BECDDC 1px solid;margin:0px" type="text" title="搜索该网站 [alt-f]" accesskey="f" value="">
			<div style="width:100%;float:left;padding-top:8px;">
			<input type="submit" style="width:50px;height:22px;line-height:16px" name="go" class="searchButton" id="searchGoButton" value="进入" title="如果相同的标题存在的话便直接前往该页面">&nbsp;
			<input type="submit" style="width:50px;height:22px;line-height:16px" name="fulltext" class="searchButton" id="mw-searchButton" value="搜索" title="搜索该文字的页面">
			</div>
			</form>

		</div><!-- pBody -->
	</div><!-- portlet -->
	<!-- toolbox -->
	<div class="portlet" id="p-tb">
		<h5>工具箱</h5>
		<div class="pBody">
			<ul>
				<li id="t-whatlinkshere"><a href="http://baike.corp.taobao.com/index.php/Special:%E9%93%BE%E5%85%A5%E9%A1%B5%E9%9D%A2/Metaq-User-Guide" title="列出所有与此页相链的页面 [j]" accesskey="j">链入页面</a></li>
				<li id="t-recentchangeslinked"><a href="http://baike.corp.taobao.com/index.php/Special:RecentChangesLinked/Metaq-User-Guide" title="从此页链出的所有页面的更改 [k]" accesskey="k">链出更改</a></li>
<li id="t-specialpages"><a href="http://baike.corp.taobao.com/index.php/Special:%E7%89%B9%E6%AE%8A%E9%A1%B5%E9%9D%A2" title="所有特殊页面列表 [q]" accesskey="q">特殊页面</a></li>
				<li id="t-print"><a href="http://baike.corp.taobao.com/index.php?title=Metaq-User-Guide&printable=yes" title="这个页面的可打印版本 [p]" accesskey="p">可打印版</a></li>				<li id="t-permalink"><a href="http://baike.corp.taobao.com/index.php?title=Metaq-User-Guide&oldid=239352" title="这个页面版本的永久链接">永久链接</a></li>			</ul>
		</div><!-- pBody -->
	</div><!-- portlet -->
	<!-- languages -->

	</div><!-- mw_portlets -->


	</div><!-- main -->

	<div class="mw_clear"></div>

	<!-- personal portlet -->

		<script type="text/javascript">if (window.runOnloadHook) runOnloadHook();</script>
<!-- Served in 0.155 secs. --><script type="text/javascript" src="./userguide_files/tongji(1).js"></script><img src="./userguide_files/tongji(2).do" border="0" width="1" height="1"><a href="http://tongji.linezing.com/report.html?unit_id=2225939" target="_blank"><img src="./userguide_files/icon1.gif" border="0" alt="量子统计"></a><noscript>&lt;a href="http://www.linezing.com"&gt;&lt;img src="http://img.tongji.linezing.com/2225939/tongji.gif"/&gt;&lt;/a&gt;</noscript>

<!-- JiaThis Button BEGIN -->
<script type="text/javascript" >
var jiathis_config={
	data_track_clickback:true,
	url:"http://metaq.taobao.org/",
	summary:"Metaq是一款分布式、高性能、高可靠适应互联网应用的消息中间件，在阿里巴巴各个子公司广泛应用，每天处理250亿+条消息。最新开源版本2.1.3.1",
	title:"@淘宝METAQ 淘宝Metaq开源消息中间件 #Metaq#",
	showClose:true,
	hideMore:false
}
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jiathis_r.js?uid=1729682&btn=r5.gif&move=0" charset="utf-8"></script>
<!-- JiaThis Button END -->
</body></html>